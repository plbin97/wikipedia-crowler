<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Binary search tree - Wikipedia</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Binary_search_tree","wgTitle":"Binary search tree","wgCurRevisionId":881157393,"wgRevisionId":881157393,"wgArticleId":4320,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["CS1: long volume value","Articles with example C++ code","Articles with example Python code","Binary trees","Data types","Search trees"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Binary_search_tree","wgRelevantArticleId":4320,"wgRequestId":"XGuAeApAAD8AAE4dXV0AAABD","wgCSPNonce":false,"wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"Binary_search_trees","wgFlaggedRevsParams":{"tags":{}},"wgStableRevisionId":null,"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgWikiEditorEnabledModules":[],"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsShouldSendModuleToUser":true,"wgPopupsConflictsWithNavPopupGadget":false,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en","usePageImages":true,"usePageDescriptions":true},"wgMFIsPageContentModelEditable":true,"wgMFEnableFontChanger":true,"wgMFDisplayWikibaseDescriptions":{"search":true,"nearby":true,"watchlist":true,"tagline":false},"wgRelatedArticles":null,"wgRelatedArticlesUseCirrusSearch":true,"wgRelatedArticlesOnlyUseCirrusSearch":false,"wgWMESchemaEditAttemptStepOversample":false,"wgPoweredByHHVM":true,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralNoticeCookiesToDelete":[],"wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgInternalRedirectTargetUrl":"/wiki/Binary_search_tree","wgWikibaseItemId":"Q623818","wgScoreNoteLanguages":{"arabic":"العربية","catalan":"català","deutsch":"Deutsch","english":"English","espanol":"español","italiano":"italiano","nederlands":"Nederlands","norsk":"norsk","portugues":"português","suomi":"suomi","svenska":"svenska","vlaams":"West-Vlams"},"wgScoreDefaultNoteLanguage":"nederlands","wgCentralAuthMobileDomain":false,"wgCodeMirrorEnabled":true,"wgVisualEditorToolbarScrollOffset":0,"wgVisualEditorUnsupportedEditParams":["undo","undoafter","veswitched"],"wgEditSubmitButtonLabelPublish":true,"oresWikiId":"enwiki","oresBaseUrl":"http://ores.discovery.wmnet:8081/","oresApiVersion":3});mw.loader.state({"ext.gadget.charinsert-styles":"ready","ext.globalCssJs.user.styles":"ready","ext.globalCssJs.site.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","ext.globalCssJs.user":"ready","ext.globalCssJs.site":"ready","user":"ready","user.options":"ready","user.tokens":"loading","ext.cite.styles":"ready","ext.pygments":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.toc.styles":"ready","wikibase.client.init":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","ext.3d.styles":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@0tffind",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});RLPAGEMODULES=["mediawiki.action.view.redirect","ext.cite.ux-enhancements","site","mediawiki.page.startup","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.watchlist-notice","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","mmv.head","mmv.bootstrap.autostart","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging","ext.wikimediaEvents","ext.navigationTiming","ext.uls.eventlogger","ext.uls.init","ext.uls.compactlinks","ext.uls.interface","ext.quicksurveys.init","ext.centralNotice.geoIP","ext.centralNotice.startUp","skins.vector.js"];mw.loader.load(RLPAGEMODULES);});</script>
<link rel="stylesheet" href="/w/load.php?debug=false&amp;lang=en&amp;modules=ext.3d.styles%7Cext.cite.styles%7Cext.pygments%2CwikimediaBadges%7Cext.uls.interlanguage%7Cext.visualEditor.desktopArticleTarget.noscript%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.toc.styles%7Cskins.vector.styles%7Cwikibase.client.init&amp;only=styles&amp;skin=vector"/>
<script async="" src="/w/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/w/load.php?debug=false&amp;lang=en&amp;modules=ext.gadget.charinsert-styles&amp;only=styles&amp;skin=vector"/>
<link rel="stylesheet" href="/w/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.33.0-wmf.17"/>
<meta name="referrer" content="origin"/>
<meta name="referrer" content="origin-when-crossorigin"/>
<meta name="referrer" content="origin-when-cross-origin"/>
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/1200px-Binary_search_tree.svg.png"/>
<link rel="alternate" href="android-app://org.wikipedia/http/en.m.wikipedia.org/wiki/Binary_search_tree"/>
<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Binary_search_tree&amp;action=edit"/>
<link rel="edit" title="Edit this page" href="/w/index.php?title=Binary_search_tree&amp;action=edit"/>
<link rel="apple-touch-icon" href="/static/apple-touch/wikipedia.png"/>
<link rel="shortcut icon" href="/static/favicon/wikipedia.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd"/>
<link rel="license" href="//creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="canonical" href="https://en.wikipedia.org/wiki/Binary_search_tree"/>
<link rel="dns-prefetch" href="//login.wikimedia.org"/>
<link rel="dns-prefetch" href="//meta.wikimedia.org" />
<!--[if lt IE 9]><script src="/w/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-Binary_search_tree rootpage-Binary_search_tree skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><!-- CentralNotice --></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Binary search tree</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Wikipedia, the free encyclopedia</div>				<div id="contentSub"><span class="mw-redirectedfrom">&#160;&#160;(Redirected from <a href="/w/index.php?title=Binary_search_trees&amp;redirect=no" class="mw-redirect" title="Binary search trees">Binary search trees</a>)</span></div>
				<div id="jump-to-nav"></div>				<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
				<a class="mw-jump-link" href="#p-search">Jump to search</a>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><table class="infobox" style="width:22em"><tbody><tr><th colspan="2" style="text-align:center;font-size:125%;font-weight:bold">Binary search tree</th></tr><tr><th scope="row"><a href="/wiki/List_of_data_structures" title="List of data structures">Type</a></th><td>tree</td></tr><tr><th scope="row">Invented</th><td>1960</td></tr><tr><th scope="row">Invented by</th><td>P.F. Windley, <a href="/wiki/Andrew_Donald_Booth" title="Andrew Donald Booth">A.D. Booth</a>, <a href="/wiki/Andrew_Colin" title="Andrew Colin">A.J.T. Colin</a>, and <a href="/wiki/Thomas_N._Hibbard" title="Thomas N. Hibbard">T.N. Hibbard</a></td></tr><tr><th colspan="2" style="text-align:center"><a href="/wiki/Time_complexity" title="Time complexity">Time complexity</a> in <a href="/wiki/Big_O_notation" title="Big O notation">big O notation</a></th></tr><tr><td colspan="2" style="text-align:center"><table class="infobox" style="padding:0;border:none;margin:auto;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent"><tbody><tr><th scope="row" style="white-space:nowrap;">Algorithm</th><td>
</td><td>
<b>Average</b></td><td>
<b>Worst case</b></td></tr><tr><th scope="row" style="white-space:nowrap;">Space</th><td>
</td><td>
<span class="texhtml"><span class="texhtml">O(<i>n</i>)</span></span></td><td>
<span class="texhtml"><span class="texhtml">O(<i>n</i>)</span></span></td></tr><tr><th scope="row" style="white-space:nowrap;">Search</th><td>
</td><td>
<span class="texhtml"><span class="texhtml">O(log <i>n</i>)</span></span></td><td>
<span class="texhtml"><span class="texhtml">O(<i>n</i>)</span></span></td></tr><tr><th scope="row" style="white-space:nowrap;">Insert</th><td>
</td><td>
<span class="texhtml"><span class="texhtml">O(log <i>n</i>)</span></span></td><td>
<span class="texhtml"><span class="texhtml">O(<i>n</i>)</span></span></td></tr><tr><th scope="row" style="white-space:nowrap;">Delete</th><td>
</td><td>
<span class="texhtml"><span class="texhtml">O(log <i>n</i>)</span></span></td><td>
<span class="texhtml"><span class="texhtml">O(<i>n</i>)</span></span></td></tr></tbody></table></td></tr></tbody></table>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="/wiki/File:Binary_search_tree.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/200px-Binary_search_tree.svg.png" decoding="async" width="200" height="167" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/400px-Binary_search_tree.svg.png 2x" data-file-width="300" data-file-height="250" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Binary_search_tree.svg" class="internal" title="Enlarge"></a></div>A binary search tree of size 9 and depth 3, with 8 at the root. The leaves are not drawn.</div></div></div>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>binary search trees</b> (<b>BST</b>), sometimes called <b>ordered</b> or <b>sorted binary trees</b>, are a particular type of <a href="/wiki/Collection_(abstract_data_type)" title="Collection (abstract data type)">container</a>: <a href="/wiki/Data_structure" title="Data structure">data structures</a> that store "items" (such as numbers, names etc.) in <a href="/wiki/Computer_memory" title="Computer memory">memory</a>. They allow fast lookup, addition and removal of items, and can be used to implement either <a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">dynamic sets</a> of items, or <a href="/wiki/Lookup_table" title="Lookup table">lookup tables</a> that allow finding an item by its <i>key</i> (e.g., finding the phone number of a person by name).
</p><p>Binary search trees keep their keys in sorted order, so that lookup and other operations can use the principle of <a href="/wiki/Binary_search" class="mw-redirect" title="Binary search">binary search</a>: when looking for a key in a tree (or a place to insert a new key), they traverse the tree from root to leaf, making comparisons to keys stored in the nodes of the tree and deciding, on the basis of the comparison, to continue searching in the left or right subtrees. On average, this means that each comparison allows the operations to skip about half of the tree, so that each lookup, insertion or deletion takes <a href="/wiki/Time_complexity" title="Time complexity">time proportional to</a> the <a href="/wiki/Logarithm" title="Logarithm">logarithm</a> of the number of items stored in the tree. This is much better than the <a href="/wiki/Linear_time" class="mw-redirect" title="Linear time">linear time</a> required to find items by key in an (unsorted) array, but slower than the corresponding operations on <a href="/wiki/Hash_table" title="Hash table">hash tables</a>.
</p><p>Several variants of the binary search tree have been studied in computer science; this article deals primarily with the basic type, making references to more advanced types when appropriate.
</p>
<div id="toc" class="toc"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Definition"><span class="tocnumber">1</span> <span class="toctext">Definition</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Order_relation"><span class="tocnumber">1.1</span> <span class="toctext">Order relation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="#Operations"><span class="tocnumber">2</span> <span class="toctext">Operations</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Searching"><span class="tocnumber">2.1</span> <span class="toctext">Searching</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Insertion"><span class="tocnumber">2.2</span> <span class="toctext">Insertion</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Deletion"><span class="tocnumber">2.3</span> <span class="toctext">Deletion</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Traversal"><span class="tocnumber">2.4</span> <span class="toctext">Traversal</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Verification"><span class="tocnumber">2.5</span> <span class="toctext">Verification</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Examples_of_applications"><span class="tocnumber">3</span> <span class="toctext">Examples of applications</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Sort"><span class="tocnumber">3.1</span> <span class="toctext">Sort</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Priority_queue_operations"><span class="tocnumber">3.2</span> <span class="toctext">Priority queue operations</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#Types"><span class="tocnumber">4</span> <span class="toctext">Types</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="#Performance_comparisons"><span class="tocnumber">4.1</span> <span class="toctext">Performance comparisons</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Optimal_binary_search_trees"><span class="tocnumber">4.2</span> <span class="toctext">Optimal binary search trees</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Notes"><span class="tocnumber">6</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#Further_reading"><span class="tocnumber">8</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1 tocsection-19"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=1" title="Edit section: Definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A binary search tree is a <a href="/wiki/Rooted_tree" class="mw-redirect" title="Rooted tree">rooted</a> <a href="/wiki/Binary_tree" title="Binary tree">binary tree</a>, whose internal nodes each store a key (and optionally, an associated value) and each have two distinguished sub-trees, commonly denoted <i>left</i> and <i>right</i>. The tree additionally satisfies the <a href="/wiki/Binary_search" class="mw-redirect" title="Binary search">binary search</a> property, which states that the key in each node must be greater than or equal to any key stored in the left sub-tree, and less than or equal to any key stored in the right sub-tree.<sup id="cite_ref-clrs_1-0" class="reference"><a href="#cite_note-clrs-1">&#91;1&#93;</a></sup><sup class="reference" style="white-space:nowrap;">:<span>287</span></sup> The leaves (final nodes) of the tree contain no key and have no structure to distinguish them from one another. 
</p><p>Frequently, the information represented by each node is a record rather than a single data element.  However, for sequencing purposes, nodes are compared according to their keys rather than any part of their associated records. The major advantage of binary search trees over other data structures is that the related <a href="/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithms</a> and <a href="/wiki/Search_algorithm" title="Search algorithm">search algorithms</a> such as <a href="/wiki/In-order_traversal" class="mw-redirect" title="In-order traversal">in-order traversal</a> can be very efficient; they are also easy to code.
</p><p>Binary search trees are a fundamental data structure used to construct more abstract data structures such as <a href="/wiki/Set_(computer_science)" class="mw-redirect" title="Set (computer science)">sets</a>, <a href="/wiki/Set_(computer_science)#Multiset" class="mw-redirect" title="Set (computer science)">multisets</a>, and <a href="/wiki/Associative_array" title="Associative array">associative arrays</a>.
</p>
<ul><li>When inserting or searching for an element in a binary search tree, the key of each visited node has to be compared with the key of the element to be inserted or found.</li>
<li>The shape of the binary search tree depends entirely on the order of insertions and deletions, and can become degenerate.</li>
<li>After a long intermixed sequence of random insertion and deletion, the expected height of the tree approaches square root of the number of keys, <span class="texhtml"><span class="nowrap">&#8730;<span style="border-top:1px solid; padding:0 0.1em;"><i>n</i></span></span></span>, which grows much faster than <span class="texhtml">log <i>n</i></span>.</li>
<li>There has been a lot of research to prevent degeneration of the tree resulting in worst case time complexity of <span class="texhtml">O(<i>n</i>)</span> (for details see section <a href="#Types">Types</a>).</li></ul>
<h3><span class="mw-headline" id="Order_relation">Order relation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=2" title="Edit section: Order relation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Binary search requires an order relation by which every element (item) can be compared with every other element in the sense of a <a href="/wiki/Total_preorder" class="mw-redirect" title="Total preorder">total preorder</a>. The part of the element which effectively takes place in the comparison is called its <i>key</i>. Whether duplicates, i.e. different elements with same key, shall be allowed in the tree or not, does not depend on the order relation, but on the application only.
</p><p>In the context of binary search trees a total preorder is realized most flexibly by means of a <a href="/wiki/Three-way_comparison" title="Three-way comparison">three-way comparison</a> <a href="/wiki/Subroutine" title="Subroutine">subroutine</a>.
</p>
<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=3" title="Edit section: Operations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Binary search trees support three main operations: insertion of elements, deletion of elements, and lookup (checking whether a key is present).
</p>
<h3><span class="mw-headline" id="Searching">Searching</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=4" title="Edit section: Searching">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Searching a binary search tree for a specific key can be programmed <a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">recursively</a> or <a href="/wiki/Iteration#Computing" title="Iteration">iteratively</a>.
</p><p>We begin by examining the <a href="/wiki/Tree_(data_structure)#root_nodes" title="Tree (data structure)">root node</a>. If the tree is <i>null</i>, the key we are searching for does not exist in the tree. Otherwise, if the key equals that of the root, the search is successful and we return the node. If the key is less than that of the root, we search the left subtree. Similarly, if the key is greater than that of the root, we search the right subtree. This process is repeated until the key is found or the remaining subtree is <i>null</i>. If the searched key is not found after a <i>null</i> subtree is reached, then the key is not present in the tree. This is easily expressed as a recursive algorithm (implemented in <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>):
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="lineno">1 </span><span class="k">def</span> <span class="nf">search_recursively</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="lineno">2 </span>    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
<span class="lineno">3 </span>        <span class="k">return</span> <span class="n">node</span>
<span class="lineno">4 </span>    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
<span class="lineno">5 </span>        <span class="k">return</span> <span class="n">search_recursively</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
<span class="lineno">6 </span>    <span class="c1"># key &gt; node.key</span>
<span class="lineno">7 </span>    <span class="k">return</span> <span class="n">search_recursively</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>
<p>The same algorithm can be implemented iteratively:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="lineno"> 1 </span><span class="k">def</span> <span class="nf">search_iteratively</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> 
<span class="lineno"> 2 </span>    <span class="n">current_node</span> <span class="o">=</span> <span class="n">node</span>
<span class="lineno"> 3 </span>    <span class="k">while</span> <span class="n">current_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
<span class="lineno"> 4 </span>        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">current_node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
<span class="lineno"> 5 </span>            <span class="k">return</span> <span class="n">current_node</span>
<span class="lineno"> 6 </span>        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">current_node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
<span class="lineno"> 7 </span>            <span class="n">current_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">left</span>
<span class="lineno"> 8 </span>        <span class="k">else</span><span class="p">:</span> <span class="c1"># key &gt; current_node.key:</span>
<span class="lineno"> 9 </span>            <span class="n">current_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">right</span>
<span class="lineno">10 </span>    <span class="k">return</span> <span class="n">current_node</span>
</pre></div>
<p>These two examples rely on the order relation being a total order.
</p><p>If the order relation is only a total preorder, a reasonable extension of the functionality is the following: also in case of equality search down to the leaves in a direction specified by the user. A <a href="/wiki/Tree_sort" title="Tree sort">binary tree sort</a> equipped with such a comparison function becomes <a href="/wiki/Sorting_algorithm#Stability" title="Sorting algorithm">stable</a>.
</p><p>Because in the worst case this algorithm must search from the root of the tree to the leaf farthest from the root, the search operation takes time proportional to the tree's <i>height</i> (see <a href="/wiki/Tree_(data_structure)#Terminology" title="Tree (data structure)">tree terminology</a>). On average, binary search trees with <span class="texhtml"><i>n</i></span> nodes have <span class="texhtml"><a href="/wiki/Big_O_notation" title="Big O notation">O</a>(log <i>n</i>)</span> height.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2">&#91;note 1&#93;</a></sup> However, in the worst case, binary search trees can have <span class="texhtml">O(<i>n</i>)</span> height, when the unbalanced tree resembles a <a href="/wiki/Linked_list" title="Linked list">linked list</a> (<a href="/wiki/Binary_Tree#Types_of_binary_trees" class="mw-redirect" title="Binary Tree">degenerate tree</a>).
</p>
<h3><span class="mw-headline" id="Insertion">Insertion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=5" title="Edit section: Insertion">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Insertion begins as a search would begin; if the key is not equal to that of the root, we search the left or right subtrees as before. Eventually, we will reach an external node and add the new key-value pair (here encoded as a record 'newNode') as its right or left child, depending on the node's key. In other words, we examine the root and recursively insert the new node to the left subtree if its key is less than that of the root, or the right subtree if its key is greater than or equal to the root.
</p><p>Here's how a typical binary search tree insertion might be performed in a binary tree in <a href="/wiki/C%2B%2B" title="C++">C++</a>:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*&amp;</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> 
    <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="k">else</span>  <span class="c1">// key &gt; root-&gt;key</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>The above <i>destructive</i> procedural variant modifies the tree in place. It uses only constant heap space (and the iterative version uses constant stack space as well), but the prior version of the tree is lost. Alternatively, as in the following <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a> example, we can reconstruct all ancestors of the inserted node; any reference to the original tree root remains valid, making the tree a <a href="/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structure</a>:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="k">def</span> <span class="nf">binary_tree_insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
   <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">NodeTree</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">NodeTree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">NodeTree</span><span class="p">(</span><span class="n">binary_tree_insert</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">NodeTree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">binary_tree_insert</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
</pre></div>
<p>The part that is rebuilt uses <span class="texhtml"><a href="/wiki/Big_O_notation" title="Big O notation">O</a>(log <i>n</i>)</span> space in the average case and <span class="texhtml">O(<i>n</i>)</span> in the worst case.
</p><p>In either version, this operation requires time proportional to the height of the tree in the worst case, which is <span class="texhtml">O(log <i>n</i>)</span> time in the average case over all trees, but <span class="texhtml">O(<i>n</i>)</span> time in the worst case.
</p><p>Another way to explain insertion is that in order to insert a new node in the tree, its key is first compared with that of the root. If its key is less than the root's, it is then compared with the key of the root's left child. If its key is greater, it is compared with the root's right child. This process continues, until the new node is compared with a leaf node, and then it is added as this node's right or left child, depending on its key: if the key is less than the leaf's key, then it is inserted as the leaf's left child, otherwise as the leaf's right child.
</p><p>There are other ways of inserting nodes into a binary tree, but this is the only way of inserting nodes at the leaves and at the same time preserving the BST structure.
</p>
<h3><span class="mw-headline" id="Deletion">Deletion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=6" title="Edit section: Deletion">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When removing a node from a binary <i>search</i> tree it is mandatory to maintain the in-order sequence of the nodes.
There are many possibilities to do this. However, the following method which has been proposed by T. Hibbard in 1962<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">&#91;2&#93;</a></sup> guarantees that the heights of the subject subtrees are changed by at most one.
There are three possible cases to consider:
</p>
<ul><li>Deleting a node with no children: simply remove the node from the tree.</li>
<li>Deleting a node with one child: remove the node and replace it with its child.</li>
<li>Deleting a node with two children: call the node to be deleted <i>D</i>.  Do not delete <i>D</i>.  Instead, choose either its <a href="/wiki/Tree_traversal" title="Tree traversal">in-order</a> predecessor node or its in-order successor node as replacement node <i>E</i> (s. figure). Copy the user values of <i>E</i> to <i>D</i>.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">&#91;note 2&#93;</a></sup> If <i>E</i> does not have a child simply remove <i>E</i> from its previous parent <i>G</i>. If <i>E</i> has a child, say <i>F</i>, it is a right child. Replace <i>E</i> with <i>F</i> at <i>E</i>'s parent.</li></ul>
<div class="thumb tright"><div class="thumbinner" style="width:502px;"><a href="/wiki/File:AVL-tree-delete.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/3/36/AVL-tree-delete.svg/500px-AVL-tree-delete.svg.png" decoding="async" width="500" height="134" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/36/AVL-tree-delete.svg/750px-AVL-tree-delete.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/36/AVL-tree-delete.svg/1000px-AVL-tree-delete.svg.png 2x" data-file-width="2106" data-file-height="564" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:AVL-tree-delete.svg" class="internal" title="Enlarge"></a></div>Deleting a node with two children from a binary search tree. First the leftmost node in the right subtree, the in-order successor <i>E</i>, is identified. Its value is copied into the node <i>D</i> being deleted. The in-order successor can then be easily deleted because it has at most one child. The same method works symmetrically using the in-order predecessor <i>C</i>.</div></div></div>
<p>In all cases, when <i>D</i> happens to be the root, make the replacement node root again.
</p><p>Broadly speaking, nodes with children are harder to delete. As with all binary trees, a node's in-order successor is its right subtree's left-most child, and a node's in-order predecessor is the left subtree's right-most child. In either case, this node will have only one or no child at all. Delete it according to one of the two simpler cases above.
</p><p>Consistently using the in-order successor or the in-order predecessor for every instance of the two-child case can lead to an <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">unbalanced</a> tree, so some implementations select one or the other at different times.
</p><p>Runtime analysis: Although this operation does not always traverse the tree down to a leaf, this is always a possibility; thus in the worst case it requires time proportional to the height of the tree. It does not require more even when the node has two children, since it still follows a single path and does not visit any node twice.
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="k">def</span> <span class="nf">find_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>   <span class="c1"># Gets minimum node in a subtree</span>
    <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">while</span> <span class="n">current_node</span><span class="o">.</span><span class="n">left_child</span><span class="p">:</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">left_child</span>
    <span class="k">return</span> <span class="n">current_node</span>

<span class="k">def</span> <span class="nf">replace_node_in_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left_child</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left_child</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right_child</span> <span class="o">=</span> <span class="n">new_value</span>
    <span class="k">if</span> <span class="n">new_value</span><span class="p">:</span>
        <span class="n">new_value</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>

<span class="k">def</span> <span class="nf">binary_tree_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_child</span><span class="o">.</span><span class="n">binary_tree_delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_child</span><span class="o">.</span><span class="n">binary_tree_delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># delete the key here</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_child</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_child</span><span class="p">:</span> <span class="c1"># if both children are present</span>
        <span class="n">successor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_child</span><span class="o">.</span><span class="n">find_min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">successor</span><span class="o">.</span><span class="n">key</span>
        <span class="n">successor</span><span class="o">.</span><span class="n">binary_tree_delete</span><span class="p">(</span><span class="n">successor</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_child</span><span class="p">:</span>   <span class="c1"># if the node has only a *left* child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replace_node_in_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_child</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_child</span><span class="p">:</span>  <span class="c1"># if the node has only a *right* child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replace_node_in_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right_child</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replace_node_in_parent</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># this node has no children</span>
</pre></div>
<h3><span class="mw-headline" id="Traversal">Traversal</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=7" title="Edit section: Traversal">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Tree_traversal" title="Tree traversal">Tree traversal</a></div>
<p>Once the binary search tree has been created, its elements can be retrieved <a href="/wiki/In-order_traversal" class="mw-redirect" title="In-order traversal">in-order</a> by <a href="/wiki/Recursion" title="Recursion">recursively</a> traversing the left subtree of the root node, accessing the node itself, then recursively traversing the right subtree of the node, continuing this pattern with each node in the tree as it's recursively accessed. As with all binary trees, one may conduct a <a href="/wiki/Pre-order_traversal" class="mw-redirect" title="Pre-order traversal">pre-order traversal</a> or a <a href="/wiki/Post-order_traversal" class="mw-redirect" title="Post-order traversal">post-order traversal</a>, but neither are likely to be useful for binary <i>search</i> trees. An in-order traversal of a binary search tree will always result in a sorted list of node items (numbers, strings or other comparable items).
</p><p>The code for in-order traversal in Python is given below. It will call <b><a href="/wiki/Callback_(computer_programming)" title="Callback (computer programming)">callback</a></b> (some function the programmer wishes to call on the node's value, such as printing to the screen) for every node in the tree.
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="k">def</span> <span class="nf">traverse_binary_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">traverse_binary_tree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
    <span class="n">callback</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">traverse_binary_tree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>
<p>Traversal requires <span class="texhtml"><a href="/wiki/Big_O_notation" title="Big O notation">O</a>(<i>n</i>)</span> time, since it must visit every node. This algorithm is also <span class="texhtml">O(<i>n</i>)</span>, so it is <a href="/wiki/Asymptotically_optimal" class="mw-redirect" title="Asymptotically optimal">asymptotically optimal</a>.
</p><p>Traversal can also be implemented <a href="/wiki/Iteration#Computing" title="Iteration">iteratively</a>. For certain applications, e.g. greater equal search, approximative search, an operation for <span id="sst"></span><i>single step (iterative) traversal</i> can be very useful. This is, of course, implemented without the callback construct and takes <span class="texhtml">O(1)</span> on average and <span class="texhtml">O(log <i>n</i>)</span> in the worst case.
</p>
<h3><span class="mw-headline" id="Verification">Verification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=8" title="Edit section: Verification">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Sometimes we already have a binary tree, and we need to determine whether it is a BST. This problem has a simple recursive solution.
</p><p>The BST property—every node on the right subtree has to be larger than the current node and every node on the left subtree has to be smaller than the current node—is the key to figuring out whether a tree is a BST or not. The <a href="/wiki/Greedy_algorithm" title="Greedy algorithm">greedy algorithm</a>—simply traverse the tree, at every node check whether the node contains a value larger than the value at the left child and smaller than the value on the right child—does not work for all cases. Consider the following tree:
</p>
<pre>     20
    /  \
  10    30
       /  \
      5    40
</pre>
<p>In the tree above, each node meets the condition that the node contains a value larger than its left child and smaller than its right child hold, and yet it is not a BST: the value 5 is on the right subtree of the node containing 20, a violation of the BST property.
</p><p>Instead of making a decision based solely on the values of a node and its children, we also need information flowing down from the parent as well. In the case of the tree above, if we could remember about the node containing the value 20, we would see that the node with value 5 is violating the BST property contract.
</p><p>So the condition we need to check at each node is: 
</p>
<ul><li>if the node is the left child of its parent, then it must be smaller than (or equal to) the parent and it must pass down the value from its parent to its right subtree to make sure none of the nodes in that subtree is greater than the parent</li>
<li>if the node is the right child of its parent, then it must be larger than the parent and it must pass down the value from its parent to its left subtree to make sure none of the nodes in that subtree is lesser than the parent.</li></ul>
<p>A recursive solution in C++ can explain this further:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span> <span class="n">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="nf">isBST</span><span class="p">(</span><span class="k">struct</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minKey</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">minKey</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">maxKey</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">isBST</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">minKey</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBST</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxKey</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p><code>node-&gt;key+1</code> and <code>node-&gt;key-1</code> are done to allow only distinct elements in BST.
</p><p>If we want same elements to also be present, then we can use only <code>node-&gt;key</code> in both places.
</p><p>The initial call to this function can be something like this:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">isBST</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&quot;This is a BST.&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&quot;This is NOT a BST!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Essentially we keep creating a valid range (starting from [MIN_VALUE, MAX_VALUE]) and keep shrinking it down for each node as we go down recursively.
</p><p>As pointed out in section <a href="#Traversal">#Traversal</a>, an in-order traversal of a binary <i>search</i> tree returns the nodes sorted. Thus we only need to keep the last visited node while traversing the tree and check whether its key is smaller (or smaller/equal, if duplicates are to be allowed in the tree) compared to the current key.
</p>
<h2><span class="mw-headline" id="Examples_of_applications">Examples of applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=9" title="Edit section: Examples of applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Sort">Sort</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=10" title="Edit section: Sort">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Tree_sort" title="Tree sort">Tree sort</a></div>
<p>A binary search tree can be used to implement a simple <a href="/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithm</a>. Similar to <a href="/wiki/Heapsort" title="Heapsort">heapsort</a>, we insert all the values we wish to sort into a new ordered data structure—in this case a binary search tree—and then traverse it in order.
</p><p>The worst-case time of <code>build_binary_tree</code> is <span class="texhtml">O(<i>n</i><sup>2</sup>)</span>—if you feed it a sorted list of values, it chains them into a <a href="/wiki/Linked_list" title="Linked list">linked list</a> with no left subtrees. For example, <code>build_binary_tree([1, 2, 3, 4, 5])</code> yields the tree <code>(1 (2 (3 (4 (5)))))</code>.
</p><p>There are several schemes for overcoming this flaw with simple binary trees; the most common is the <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search tree</a>. If this same procedure is done using such a tree, the overall worst-case time is <span class="texhtml">O(<i>n</i> log <i>n</i>)</span>, which is <a href="/wiki/Asymptotically_optimal" class="mw-redirect" title="Asymptotically optimal">asymptotically optimal</a> for a <a href="/wiki/Comparison_sort" title="Comparison sort">comparison sort</a>. In practice, the added overhead in time and space for a tree-based sort (particularly for node <a href="/wiki/Dynamic_memory_allocation" class="mw-redirect" title="Dynamic memory allocation">allocation</a>) make it inferior to other asymptotically optimal sorts such as  <a href="/wiki/Heapsort" title="Heapsort">heapsort</a> for static list sorting. On the other hand, it is one of the most efficient methods of <i>incremental sorting</i>, adding items to a list over time while keeping the list sorted at all times.
</p>
<h3><span class="mw-headline" id="Priority_queue_operations">Priority queue operations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=11" title="Edit section: Priority queue operations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Binary search trees can serve as <a href="/wiki/Priority_queue" title="Priority queue">priority queues</a>: structures that allow insertion of arbitrary key as well as lookup and deletion of the minimum (or maximum) key. Insertion works as previously explained. <i>Find-min</i> walks the tree, following left pointers as far as it can without hitting a leaf:
</p>
<pre><i>// Precondition: T is not a leaf</i>
<b>function</b> find-min(T):
    <b>while</b> hasLeft(T):
        T&#160;? left(T)
    <b>return</b> key(T)
</pre>
<p><i>Find-max</i> is analogous: follow right pointers as far as possible. <i>Delete-min</i> (<i>max</i>) can simply look up the minimum (maximum), then delete it. This way, insertion and deletion both take logarithmic time, just as they do in a <a href="/wiki/Binary_heap" title="Binary heap">binary heap</a>, but unlike a binary heap and most other priority queue implementations, a single tree can support all of <i>find-min</i>, <i>find-max</i>, <i>delete-min</i> and <i>delete-max</i> at the same time, making binary search trees suitable as <a href="/wiki/Double-ended_priority_queue" title="Double-ended priority queue">double-ended priority queues</a>.<sup id="cite_ref-mehlhorn_5-0" class="reference"><a href="#cite_note-mehlhorn-5">&#91;3&#93;</a></sup><sup class="reference" style="white-space:nowrap;">:<span>156</span></sup>
</p>
<h2><span class="mw-headline" id="Types">Types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=12" title="Edit section: Types">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are many types of binary search trees. <a href="/wiki/AVL_tree" title="AVL tree">AVL trees</a> and <a href="/wiki/Red-black_tree" class="mw-redirect" title="Red-black tree">red-black trees</a> are both forms of <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search trees</a>. A <a href="/wiki/Splay_tree" title="Splay tree">splay tree</a> is a binary search tree that automatically moves frequently accessed elements nearer to the root. In a <a href="/wiki/Treap" title="Treap">treap</a> (<i>tree <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">heap</a></i>), each node also holds a (randomly chosen) priority and the parent node has higher priority than its children. <a href="/wiki/Tango_tree" title="Tango tree">Tango trees</a> are trees optimized for fast searches.
<a href="/wiki/T-tree" title="T-tree">T-trees</a> are binary search trees optimized to reduce storage space overhead, widely used for in-memory databases
</p><p>A degenerate tree is a tree where for each parent node, there is only one associated child node. It is unbalanced and, in the worst case, performance degrades to that of a linked list. If your add node function does not handle re-balancing, then you can easily construct a degenerate tree by feeding it with data that is already sorted. What this means is that in a performance measurement, the tree will  essentially behave like a linked list data structure.
</p>
<h3><span class="mw-headline" id="Performance_comparisons">Performance comparisons</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=13" title="Edit section: Performance comparisons">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>D. A. Heger (2004)<sup id="cite_ref-6" class="reference"><a href="#cite_note-6">&#91;4&#93;</a></sup> presented a performance comparison of binary search trees. <a href="/wiki/Treap" title="Treap">Treap</a> was found to have the best average performance, while <a href="/wiki/Red-black_tree" class="mw-redirect" title="Red-black tree">red-black tree</a> was found to have the smallest number of performance variations.
</p>
<h3><span class="mw-headline" id="Optimal_binary_search_trees">Optimal binary search trees</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=14" title="Edit section: Optimal binary search trees">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Optimal_binary_search_tree" title="Optimal binary search tree">Optimal binary search tree</a></div>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="/wiki/File:BinaryTreeRotations.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/300px-BinaryTreeRotations.svg.png" decoding="async" width="300" height="166" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/450px-BinaryTreeRotations.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/600px-BinaryTreeRotations.svg.png 2x" data-file-width="405" data-file-height="224" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:BinaryTreeRotations.svg" class="internal" title="Enlarge"></a></div>Tree rotations are very common internal operations in binary trees to keep perfect, or near-to-perfect, internal balance in the tree.</div></div></div>
<p>If we do not plan on modifying a search tree, and we know exactly how often each item will be accessed, we can construct<sup id="cite_ref-7" class="reference"><a href="#cite_note-7">&#91;5&#93;</a></sup> an <i>optimal binary search tree</i>, which is a search tree where the average cost of looking up an item (the <i>expected search cost</i>) is minimized.
</p><p>Even if we only have estimates of the search costs, such a system can considerably speed up lookups on average. For example, if you have a BST of English words used in a <a href="/wiki/Spell_checker" title="Spell checker">spell checker</a>, you might balance the tree based on word frequency in <a href="/wiki/Text_corpus" title="Text corpus">text corpora</a>, placing words like <i>the</i> near the root and words like <i>agerasia</i> near the leaves. Such a tree might be compared with <a href="/wiki/Huffman_tree" class="mw-redirect" title="Huffman tree">Huffman trees</a>, which similarly seek to place frequently used items near the root in order to produce a dense information encoding; however, Huffman trees store data elements only in leaves, and these elements need not be ordered.
</p><p>If we do not know the sequence in which the elements in the tree will be accessed in advance, we can use <a href="/wiki/Splay_tree" title="Splay tree">splay trees</a> which are asymptotically as good as any static search tree we can construct for any particular sequence of lookup operations.
</p><p><i>Alphabetic trees</i> are Huffman trees with the additional constraint on order, or, equivalently, search trees with the modification that all elements are stored in the leaves. Faster algorithms exist for <i>optimal alphabetic binary trees</i> (OABTs).
</p>
<div style="clear:both;"></div>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=15" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="div-col columns column-width" style="-moz-column-width: 30em; -webkit-column-width: 30em; column-width: 30em;">
<ul><li><a href="/wiki/Binary_search_algorithm" title="Binary search algorithm">Binary search algorithm</a></li>
<li><a href="/wiki/Search_tree" title="Search tree">Search tree</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">Self-balancing binary search tree</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL tree</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">Red–black tree</a></li>
<li><a href="/wiki/Randomized_binary_search_tree" class="mw-redirect" title="Randomized binary search tree">Randomized binary search tree</a></li>
<li><a href="/wiki/Tango_tree" title="Tango tree">Tango tree</a></li></ul>
</div>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=16" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="reflist" style="list-style-type: decimal;">
<div class="mw-references-wrap"><ol class="references">
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">The notion of an average BST is made precise as follows. Let a random BST be one built using only insertions out of a sequence of unique elements in random order (all permutations equally likely); then the <a href="/wiki/Expected_value" title="Expected value">expected</a> height of the tree is <span class="texhtml">O(log <i>n</i>)</span>. If deletions are allowed as well as insertions, "little is known about the average height of a binary search tree".<sup id="cite_ref-clrs_1-1" class="reference"><a href="#cite_note-clrs-1">&#91;1&#93;</a></sup><sup class="reference" style="white-space:nowrap;">:<span>300</span></sup></span>
</li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Of course, a generic software package has to work the other way around: It has to leave the user data untouched and to furnish <i>E</i> with all the BST links to and from <i>D</i>.</span>
</li>
</ol></div></div>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=17" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="reflist" style="list-style-type: decimal;">
<div class="mw-references-wrap"><ol class="references">
<li id="cite_note-clrs-1"><span class="mw-cite-backlink">^ <a href="#cite_ref-clrs_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-clrs_1-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><cite class="citation book"><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Cormen, Thomas H.</a>; <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Leiserson, Charles E.</a>; <a href="/wiki/Ron_Rivest" title="Ron Rivest">Rivest, Ronald L.</a>; <a href="/wiki/Clifford_Stein" title="Clifford Stein">Stein, Clifford</a> (2009) [1990]. <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i> (3rd ed.). MIT Press and McGraw-Hill. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-262-03384-4" title="Special:BookSources/0-262-03384-4">0-262-03384-4</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Introduction+to+Algorithms&amp;rft.edition=3rd&amp;rft.pub=MIT+Press+and+McGraw-Hill&amp;rft.date=2009&amp;rft.isbn=0-262-03384-4&amp;rft.aulast=Cormen&amp;rft.aufirst=Thomas+H.&amp;rft.au=Leiserson%2C+Charles+E.&amp;rft.au=Rivest%2C+Ronald+L.&amp;rft.au=Stein%2C+Clifford&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><style data-mw-deduplicate="TemplateStyles:r879151008">.mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}</style></span>
</li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">s. <a href="/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">Robert Sedgewick</a>, Kevin Wayne: <a rel="nofollow" class="external text" href="http://www.albertstam.com/Algorithms.pdf"><i>Algorithms Fourth Edition.</i></a> Pearson Education, 2011, <link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/><a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-0-321-57351-3" title="Special:BookSources/978-0-321-57351-3">978-0-321-57351-3</a>, p. 410.</span>
</li>
<li id="cite_note-mehlhorn-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-mehlhorn_5-0">^</a></b></span> <span class="reference-text"><cite class="citation book"><a href="/wiki/Kurt_Mehlhorn" title="Kurt Mehlhorn">Mehlhorn, Kurt</a>; <a href="/wiki/Peter_Sanders_(computer_scientist)" title="Peter Sanders (computer scientist)">Sanders, Peter</a> (2008). <a rel="nofollow" class="external text" href="http://people.mpi-inf.mpg.de/~mehlhorn/ftp/Toolbox/SortedSequences.pdf"><i>Algorithms and Data Structures: The Basic Toolbox</i></a> <span class="cs1-format">(PDF)</span>. Springer.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithms+and+Data+Structures%3A+The+Basic+Toolbox&amp;rft.pub=Springer&amp;rft.date=2008&amp;rft.aulast=Mehlhorn&amp;rft.aufirst=Kurt&amp;rft.au=Sanders%2C+Peter&amp;rft_id=http%3A%2F%2Fpeople.mpi-inf.mpg.de%2F~mehlhorn%2Fftp%2FToolbox%2FSortedSequences.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><cite id="CITEREFHeger2004" class="citation">Heger, Dominique A. (2004), <a rel="nofollow" class="external text" href="http://www.cepis.org/upgrade/files/full-2004-V.pdf">"A Disquisition on The Performance Behavior of Binary Search Tree Data Structures"</a> <span class="cs1-format">(PDF)</span>, <i>European Journal for the Informatics Professional</i>, <b>5</b> (5): 67–75</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=European+Journal+for+the+Informatics+Professional&amp;rft.atitle=A+Disquisition+on+The+Performance+Behavior+of+Binary+Search+Tree+Data+Structures&amp;rft.volume=5&amp;rft.issue=5&amp;rft.pages=67-75&amp;rft.date=2004&amp;rft.aulast=Heger&amp;rft.aufirst=Dominique+A.&amp;rft_id=http%3A%2F%2Fwww.cepis.org%2Fupgrade%2Ffiles%2Ffull-2004-V.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><cite class="citation web">Gonnet, Gaston. <a rel="nofollow" class="external text" href="https://web.archive.org/web/20141012033537/http://linneus20.ethz.ch:8080/4_7_1.html">"Optimal Binary Search Trees"</a>. <i>Scientific Computation</i>. ETH Zürich. Archived from <a rel="nofollow" class="external text" href="http://linneus20.ethz.ch:8080/4_7_1.html">the original</a> on 12 October 2014<span class="reference-accessdate">. Retrieved <span class="nowrap">1 December</span> 2013</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=Scientific+Computation&amp;rft.atitle=Optimal+Binary+Search+Trees&amp;rft.aulast=Gonnet&amp;rft.aufirst=Gaston&amp;rft_id=http%3A%2F%2Flinneus20.ethz.ch%3A8080%2F4_7_1.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
</ol></div></div>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=18" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li><img alt="" src="//upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/12px-PD-icon.svg.png" decoding="async" width="12" height="12" srcset="//upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/18px-PD-icon.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/24px-PD-icon.svg.png 2x" data-file-width="196" data-file-height="196" />&#160;This article incorporates <a href="/wiki/Copyright_status_of_work_by_the_U.S._government" class="mw-redirect" title="Copyright status of work by the U.S. government">public domain material</a>&#160;from the&#160;<a href="/wiki/National_Institute_of_Standards_and_Technology" title="National Institute of Standards and Technology">NIST</a> document:&#160;<cite class="citation web">Black, Paul E. <a rel="nofollow" class="external text" href="https://xlinux.nist.gov/dads/HTML/binarySearchTree.html">"Binary Search Tree"</a>. <i><a href="/wiki/Dictionary_of_Algorithms_and_Data_Structures" title="Dictionary of Algorithms and Data Structures">Dictionary of Algorithms and Data Structures</a></i>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=Dictionary+of+Algorithms+and+Data+Structures&amp;rft.atitle=Binary+Search+Tree&amp;rft.aulast=Black&amp;rft.aufirst=Paul+E.&amp;rft_id=https%3A%2F%2Fxlinux.nist.gov%2Fdads%2FHTML%2FbinarySearchTree.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></li>
<li><cite class="citation book"><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Cormen, Thomas H.</a>; <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Leiserson, Charles E.</a>; <a href="/wiki/Ronald_L._Rivest" class="mw-redirect" title="Ronald L. Rivest">Rivest, Ronald L.</a>; <a href="/wiki/Clifford_Stein" title="Clifford Stein">Stein, Clifford</a> (2001). "12: Binary search trees, 15.5: Optimal binary search trees". <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i> (2nd ed.). MIT Press &amp; McGraw-Hill. pp.&#160;253–272, 356–363. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-262-03293-7" title="Special:BookSources/0-262-03293-7">0-262-03293-7</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=12%3A+Binary+search+trees%2C+15.5%3A+Optimal+binary+search+trees&amp;rft.btitle=Introduction+to+Algorithms&amp;rft.pages=253-272%2C+356-363&amp;rft.edition=2nd&amp;rft.pub=MIT+Press+%26+McGraw-Hill&amp;rft.date=2001&amp;rft.isbn=0-262-03293-7&amp;rft.aulast=Cormen&amp;rft.aufirst=Thomas+H.&amp;rft.au=Leiserson%2C+Charles+E.&amp;rft.au=Rivest%2C+Ronald+L.&amp;rft.au=Stein%2C+Clifford&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></li>
<li><cite class="citation web">Jarc, Duane J. (3 December 2005). <a rel="nofollow" class="external text" href="http://nova.umuc.edu/~jarc/idsv/lesson1.html">"Binary Tree Traversals"</a>. <i>Interactive Data Structure Visualizations</i>. <a href="/wiki/University_of_Maryland" class="mw-redirect" title="University of Maryland">University of Maryland</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=Interactive+Data+Structure+Visualizations&amp;rft.atitle=Binary+Tree+Traversals&amp;rft.date=2005-12-03&amp;rft.aulast=Jarc&amp;rft.aufirst=Duane+J.&amp;rft_id=http%3A%2F%2Fnova.umuc.edu%2F~jarc%2Fidsv%2Flesson1.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></li>
<li><cite class="citation book"><a href="/wiki/Donald_Knuth" title="Donald Knuth">Knuth, Donald</a> (1997). "6.2.2: Binary Tree Searching". <i><a href="/wiki/The_Art_of_Computer_Programming" title="The Art of Computer Programming">The Art of Computer Programming</a></i>. 3: "Sorting and Searching" (3rd ed.). Addison-Wesley. pp.&#160;426–458. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-201-89685-0" title="Special:BookSources/0-201-89685-0">0-201-89685-0</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=6.2.2%3A+Binary+Tree+Searching&amp;rft.btitle=The+Art+of+Computer+Programming&amp;rft.pages=426-458&amp;rft.edition=3rd&amp;rft.pub=Addison-Wesley&amp;rft.date=1997&amp;rft.isbn=0-201-89685-0&amp;rft.aulast=Knuth&amp;rft.aufirst=Donald&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></li>
<li><cite class="citation web">Long, Sean. <a rel="nofollow" class="external text" href="http://employees.oneonta.edu/zhangs/PowerPointPlatform/resources/samples/binarysearchtree.ppt">"Binary Search Tree"</a> <span class="cs1-format">(<a href="/wiki/Microsoft_PowerPoint" title="Microsoft PowerPoint">PPT</a>)</span>. <i>Data Structures and Algorithms Visualization-A PowerPoint Slides Based Approach</i>. <a href="/wiki/SUNY_Oneonta" class="mw-redirect" title="SUNY Oneonta">SUNY Oneonta</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=Data+Structures+and+Algorithms+Visualization-A+PowerPoint+Slides+Based+Approach&amp;rft.atitle=Binary+Search+Tree&amp;rft.aulast=Long&amp;rft.aufirst=Sean&amp;rft_id=http%3A%2F%2Femployees.oneonta.edu%2Fzhangs%2FPowerPointPlatform%2Fresources%2Fsamples%2Fbinarysearchtree.ppt&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></li>
<li><cite class="citation web">Parlante, Nick (2001). <a rel="nofollow" class="external text" href="http://cslibrary.stanford.edu/110/BinaryTrees.html">"Binary Trees"</a>. <i>CS Education Library</i>. <a href="/wiki/Stanford_University" title="Stanford University">Stanford University</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=CS+Education+Library&amp;rft.atitle=Binary+Trees&amp;rft.date=2001&amp;rft.aulast=Parlante&amp;rft.aufirst=Nick&amp;rft_id=http%3A%2F%2Fcslibrary.stanford.edu%2F110%2FBinaryTrees.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=19" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li><a rel="nofollow" class="external text" href="http://btv.melezinek.cz">Binary Tree Visualizer</a> (JavaScript animation of various BT-based data structures)</li>
<li><cite class="citation web">Kovac, Kubo. <a rel="nofollow" class="external text" href="http://people.ksp.sk/~kuko/bak/">"Binary Search Trees"</a> <span class="cs1-format">(<a href="/wiki/Java_applet" title="Java applet">Java applet</a>)</span>. Korešponden?ný seminár z programovania.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Binary+Search+Trees&amp;rft.pub=Kore%C5%A1ponden%3Fn%C3%BD+semin%C3%A1r+z+programovania&amp;rft.aulast=Kovac&amp;rft.aufirst=Kubo&amp;rft_id=http%3A%2F%2Fpeople.ksp.sk%2F~kuko%2Fbak%2F&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></li>
<li><cite class="citation web">Madru, Justin (18 August 2009). <a rel="nofollow" class="external text" href="https://web.archive.org/web/20100328221436/http://jdserver.homelinux.org/wiki/Binary_Search_Tree">"Binary Search Tree"</a>. <i>JDServer</i>. Archived from <a rel="nofollow" class="external text" href="http://jdserver.homelinux.org/wiki/Binary_Search_Tree">the original</a> on 28 March 2010.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=JDServer&amp;rft.atitle=Binary+Search+Tree&amp;rft.date=2009-08-18&amp;rft.aulast=Madru&amp;rft.aufirst=Justin&amp;rft_id=http%3A%2F%2Fjdserver.homelinux.org%2Fwiki%2FBinary_Search_Tree&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/> C++ implementation.</li>
<li><a rel="nofollow" class="external text" href="http://code.activestate.com/recipes/286239/">Binary Search Tree Example in Python</a></li>
<li><cite class="citation web"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/1sf8shae%28v=vs.80%29.aspx">"References to Pointers (C++)"</a>. <i><a href="/wiki/MSDN" class="mw-redirect" title="MSDN">MSDN</a></i>. <a href="/wiki/Microsoft" title="Microsoft">Microsoft</a>. 2005.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=MSDN&amp;rft.atitle=References+to+Pointers+%28C%2B%2B%29&amp;rft.date=2005&amp;rft_id=http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2F1sf8shae%2528v%3Dvs.80%2529.aspx&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+search+tree" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/> Gives an example binary tree implementation.</li></ul>
<div role="navigation" class="navbox" aria-labelledby="Tree_data_structures" style="padding:3px"><table class="nowraplinks collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="col" class="navbox-title" colspan="2"><div class="plainlinks hlist navbar mini"><ul><li class="nv-view"><a href="/wiki/Template:CS_trees" title="Template:CS trees"><abbr title="View this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">v</abbr></a></li><li class="nv-talk"><a href="/wiki/Template_talk:CS_trees" title="Template talk:CS trees"><abbr title="Discuss this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">t</abbr></a></li><li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:CS_trees&amp;action=edit"><abbr title="Edit this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">e</abbr></a></li></ul></div><div id="Tree_data_structures" style="font-size:114%;margin:0 4em"><a href="/wiki/Tree_(data_structure)" title="Tree (data structure)">Tree data structures</a></div></th></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Search_tree" title="Search tree">Search trees</a><br />(<a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">dynamic sets</a>/<a href="/wiki/Associative_array" title="Associative array">associative arrays</a>)</th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/2%E2%80%933_tree" title="2–3 tree">2–3</a></li>
<li><a href="/wiki/2%E2%80%933%E2%80%934_tree" title="2–3–4 tree">2–3–4</a></li>
<li><a href="/wiki/AA_tree" title="AA tree">AA</a></li>
<li><a href="/wiki/(a,b)-tree" title="(a,b)-tree">(a,b)</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL</a></li>
<li><a href="/wiki/B-tree" title="B-tree">B</a></li>
<li><a href="/wiki/B%2B_tree" title="B+ tree">B+</a></li>
<li><a href="/wiki/B*-tree" class="mw-redirect" title="B*-tree">B*</a></li>
<li><a href="/wiki/Bx-tree" title="Bx-tree">B<sup>x</sup></a></li>
<li>(<a href="/wiki/Optimal_binary_search_tree" title="Optimal binary search tree">Optimal</a>)&#160;<a class="mw-selflink selflink">Binary search</a></li>
<li><a href="/wiki/Dancing_tree" title="Dancing tree">Dancing</a></li>
<li><a href="/wiki/HTree" title="HTree">HTree</a></li>
<li><a href="/wiki/Interval_tree" title="Interval tree">Interval</a></li>
<li><a href="/wiki/Order_statistic_tree" title="Order statistic tree">Order statistic</a></li>
<li>(<a href="/wiki/Left-leaning_red%E2%80%93black_tree" title="Left-leaning red–black tree">Left-leaning</a>)&#160;<a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">Red-black</a></li>
<li><a href="/wiki/Scapegoat_tree" title="Scapegoat tree">Scapegoat</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">Splay</a></li>
<li><a href="/wiki/T-tree" title="T-tree">T</a></li>
<li><a href="/wiki/Treap" title="Treap">Treap</a></li>
<li><a href="/wiki/UB-tree" title="UB-tree">UB</a></li>
<li><a href="/wiki/Weight-balanced_tree" title="Weight-balanced tree">Weight-balanced</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">Heaps</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Binary_heap" title="Binary heap">Binary</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">Binomial</a></li>
<li><a href="/wiki/Brodal_queue" title="Brodal queue">Brodal</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci</a></li>
<li><a href="/wiki/Leftist_tree" title="Leftist tree">Leftist</a></li>
<li><a href="/wiki/Pairing_heap" title="Pairing heap">Pairing</a></li>
<li><a href="/wiki/Skew_heap" title="Skew heap">Skew</a></li>
<li><a href="/wiki/Van_Emde_Boas_tree" title="Van Emde Boas tree">Van Emde Boas</a></li>
<li><a href="/wiki/Weak_heap" title="Weak heap">Weak</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Trie" title="Trie">Tries</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Ctrie" title="Ctrie">Ctrie</a></li>
<li><a href="/wiki/C-trie" title="C-trie">C-trie (compressed ADT)</a></li>
<li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash</a></li>
<li><a href="/wiki/Radix_tree" title="Radix tree">Radix</a></li>
<li><a href="/wiki/Suffix_tree" title="Suffix tree">Suffix</a></li>
<li><a href="/wiki/Ternary_search_tree" title="Ternary search tree">Ternary search</a></li>
<li><a href="/wiki/X-fast_trie" title="X-fast trie">X-fast</a></li>
<li><a href="/wiki/Y-fast_trie" title="Y-fast trie">Y-fast</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Spatial_index" class="mw-redirect" title="Spatial index">Spatial</a> data partitioning trees</th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Ball_tree" title="Ball tree">Ball</a></li>
<li><a href="/wiki/BK-tree" title="BK-tree">BK</a></li>
<li><a href="/wiki/BSP_tree" class="mw-redirect" title="BSP tree">BSP</a></li>
<li><a href="/wiki/Cartesian_tree" title="Cartesian tree">Cartesian</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert R</a></li>
<li><a href="/wiki/K-d_tree" title="K-d tree"><i>k</i>-d</a> (<a href="/wiki/Implicit_k-d_tree" title="Implicit k-d tree">implicit <i>k</i>-d</a>)</li>
<li><a href="/wiki/M-tree" title="M-tree">M</a></li>
<li><a href="/wiki/Metric_tree" title="Metric tree">Metric</a></li>
<li><a href="/wiki/MVP_tree" class="mw-redirect" title="MVP tree">MVP</a></li>
<li><a href="/wiki/Octree" title="Octree">Octree</a></li>
<li><a href="/wiki/Priority_R-tree" title="Priority R-tree">Priority R</a></li>
<li><a href="/wiki/Quadtree" title="Quadtree">Quad</a></li>
<li><a href="/wiki/R-tree" title="R-tree">R</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+</a></li>
<li><a href="/wiki/R*_tree" title="R* tree">R*</a></li>
<li><a href="/wiki/Segment_tree" title="Segment tree">Segment</a></li>
<li><a href="/wiki/Vantage-point_tree" title="Vantage-point tree">VP</a></li>
<li><a href="/wiki/X-tree" title="X-tree">X</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%">Other trees</th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Cover_tree" title="Cover tree">Cover</a></li>
<li><a href="/wiki/Exponential_tree" title="Exponential tree">Exponential</a></li>
<li><a href="/wiki/Fenwick_tree" title="Fenwick tree">Fenwick</a></li>
<li><a href="/wiki/Finger_tree" title="Finger tree">Finger</a></li>
<li><a href="/wiki/Fractal_tree_index" title="Fractal tree index">Fractal tree index</a></li>
<li><a href="/wiki/Fusion_tree" title="Fusion tree">Fusion</a></li>
<li><a href="/wiki/Hash_calendar" title="Hash calendar">Hash calendar</a></li>
<li><a href="/wiki/IDistance" title="IDistance">iDistance</a></li>
<li><a href="/wiki/K-ary_tree" title="K-ary tree">K-ary</a></li>
<li><a href="/wiki/Left-child_right-sibling_binary_tree" title="Left-child right-sibling binary tree">Left-child right-sibling</a></li>
<li><a href="/wiki/Link/cut_tree" title="Link/cut tree">Link/cut</a></li>
<li><a href="/wiki/Log-structured_merge-tree" title="Log-structured merge-tree">Log-structured merge</a></li>
<li><a href="/wiki/Merkle_tree" title="Merkle tree">Merkle</a></li>
<li><a href="/wiki/PQ_tree" title="PQ tree">PQ</a></li>
<li><a href="/wiki/Range_tree" title="Range tree">Range</a></li>
<li><a href="/wiki/SPQR_tree" title="SPQR tree">SPQR</a></li>
<li><a href="/wiki/Top_tree" title="Top tree">Top</a></li></ul>
</div></td></tr></tbody></table></div>
<div role="navigation" class="navbox" aria-labelledby="Data_structures" style="padding:3px"><table class="nowraplinks hlist collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="col" class="navbox-title" colspan="2"><div class="plainlinks hlist navbar mini"><ul><li class="nv-view"><a href="/wiki/Template:Data_structures" title="Template:Data structures"><abbr title="View this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">v</abbr></a></li><li class="nv-talk"><a href="/wiki/Template_talk:Data_structures" title="Template talk:Data structures"><abbr title="Discuss this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">t</abbr></a></li><li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_structures&amp;action=edit"><abbr title="Edit this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">e</abbr></a></li></ul></div><div id="Data_structures" style="font-size:114%;margin:0 4em"><a href="/wiki/Data_structure" title="Data structure">Data structures</a></div></th></tr><tr><th scope="row" class="navbox-group" style="width:1%">Types</th><td class="navbox-list navbox-odd" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Collection_(abstract_data_type)" title="Collection (abstract data type)">Collection</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Container</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Abstract_data_type" title="Abstract data type">Abstract</a></th><td class="navbox-list navbox-even" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Associative_array" title="Associative array">Associative array</a>
<ul><li><a href="/wiki/Multimap" title="Multimap">Multimap</a></li></ul></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">Stack</a></li>
<li><a href="/wiki/Queue_(abstract_data_type)" title="Queue (abstract data type)">Queue</a>
<ul><li><a href="/wiki/Double-ended_queue" title="Double-ended queue">Double-ended queue</a></li></ul></li>
<li><a href="/wiki/Priority_queue" title="Priority queue">Priority queue</a>
<ul><li><a href="/wiki/Double-ended_priority_queue" title="Double-ended priority queue">Double-ended priority queue</a></li></ul></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a>
<ul><li><a href="/wiki/Set_(abstract_data_type)#Multiset" title="Set (abstract data type)">Multiset</a></li>
<li><a href="/wiki/Disjoint-set_data_structure" title="Disjoint-set data structure">Disjoint-set</a></li></ul></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Array_data_structure" title="Array data structure">Arrays</a></th><td class="navbox-list navbox-odd" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Bit_array" title="Bit array">Bit array</a></li>
<li><a href="/wiki/Circular_buffer" title="Circular buffer">Circular buffer</a></li>
<li><a href="/wiki/Dynamic_array" title="Dynamic array">Dynamic array</a></li>
<li><a href="/wiki/Hash_table" title="Hash table">Hash table</a></li>
<li><a href="/wiki/Hashed_array_tree" title="Hashed array tree">Hashed array tree</a></li>
<li><a href="/wiki/Sparse_matrix" title="Sparse matrix">Sparse matrix</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Linked_data_structure" title="Linked data structure">Linked</a></th><td class="navbox-list navbox-even" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Association_list" title="Association list">Association list</a></li>
<li><a href="/wiki/Linked_list" title="Linked list">Linked list</a></li>
<li><a href="/wiki/Skip_list" title="Skip list">Skip list</a></li>
<li><a href="/wiki/Unrolled_linked_list" title="Unrolled linked list">Unrolled linked list</a></li>
<li><a href="/wiki/XOR_linked_list" title="XOR linked list">XOR linked list</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Tree_(data_structure)" title="Tree (data structure)">Trees</a></th><td class="navbox-list navbox-odd" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/B-tree" title="B-tree">B-tree</a></li>
<li><a class="mw-selflink selflink">Binary search tree</a>
<ul><li><a href="/wiki/AA_tree" title="AA tree">AA tree</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL tree</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">Red–black tree</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">Self-balancing tree</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">Splay tree</a></li></ul></li>
<li><a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">Heap</a>
<ul><li><a href="/wiki/Binary_heap" title="Binary heap">Binary heap</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">Binomial heap</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci heap</a></li></ul></li>
<li><a href="/wiki/R-tree" title="R-tree">R-tree</a>
<ul><li><a href="/wiki/R*_tree" title="R* tree">R* tree</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+ tree</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert R-tree</a></li></ul></li>
<li><a href="/wiki/Trie" title="Trie">Trie</a>
<ul><li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash tree</a></li></ul></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Graph_(abstract_data_type)" title="Graph (abstract data type)">Graphs</a></th><td class="navbox-list navbox-even" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Binary_decision_diagram" title="Binary decision diagram">Binary decision diagram</a></li>
<li><a href="/wiki/Directed_acyclic_graph" title="Directed acyclic graph">Directed acyclic graph</a></li>
<li><a href="/wiki/Deterministic_acyclic_finite_state_automaton" title="Deterministic acyclic finite state automaton">Directed acyclic word graph</a></li></ul>
</div></td></tr><tr><td class="navbox-abovebelow" colspan="2"><div>
<ul><li><a href="/wiki/List_of_data_structures" title="List of data structures">List of data structures</a></li></ul>
</div></td></tr></tbody></table></div>

<!-- 
NewPP limit report
Parsed by mw1248
Cached time: 20190203010559
Cache expiry: 2073600
Dynamic content: false
CPU time usage: 0.416 seconds
Real time usage: 1.915 seconds
Preprocessor visited node count: 2047/1000000
Preprocessor generated node count: 0/1500000
Post‐expand include size: 65456/2097152 bytes
Template argument size: 4183/2097152 bytes
Highest expansion depth: 13/40
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 51542/5000000 bytes
Number of Wikibase entities loaded: 0/400
Lua time usage: 0.162/10.000 seconds
Lua memory usage: 3.85 MB/50 MB
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1783.349      1 -total
  9.16%  163.381      2 Template:Reflist
  5.32%   94.791      4 Template:Cite_book
  4.51%   80.366      1 Template:Introduction_to_Algorithms
  3.79%   67.571      1 Template:Infobox_data_structure
  3.59%   63.992      1 Template:Infobox
  2.35%   41.930      8 Template:Cite_web
  2.20%   39.250      1 Template:ISBN
  1.68%   30.012      1 Template:Infobox3cols
  1.04%   18.571      3 Template:Main_article
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:4320-0!canonical and timestamp 20190203010557 and revision id 881157393
 -->
</div><noscript><img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></noscript></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://en.wikipedia.org/w/index.php?title=Binary_search_tree&amp;oldid=881157393">https://en.wikipedia.org/w/index.php?title=Binary_search_tree&amp;oldid=881157393</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Help:Category" title="Help:Category">Categories</a>: <ul><li><a href="/wiki/Category:Binary_trees" title="Category:Binary trees">Binary trees</a></li><li><a href="/wiki/Category:Data_types" title="Category:Data types">Data types</a></li><li><a href="/wiki/Category:Search_trees" title="Category:Search trees">Search trees</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul><li><a href="/wiki/Category:CS1:_long_volume_value" title="Category:CS1: long volume value">CS1: long volume value</a></li><li><a href="/wiki/Category:Articles_with_example_C%2B%2B_code" title="Category:Articles with example C++ code">Articles with example C++ code</a></li><li><a href="/wiki/Category:Articles_with_example_Python_code" title="Category:Articles with example Python code">Articles with example Python code</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-anonuserpage">Not logged in</li><li id="pt-anontalk"><a href="/wiki/Special:MyTalk" title="Discussion about edits from this IP address [n]" accesskey="n">Talk</a></li><li id="pt-anoncontribs"><a href="/wiki/Special:MyContributions" title="A list of edits made from this IP address [y]" accesskey="y">Contributions</a></li><li id="pt-createaccount"><a href="/w/index.php?title=Special:CreateAccount&amp;returnto=Binary+search+tree" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Binary+search+tree" title="You&#039;re encouraged to log in; however, it&#039;s not mandatory. [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="/wiki/Binary_search_tree" title="View the content page [c]" accesskey="c">Article</a></span></li><li id="ca-talk"><span><a href="/wiki/Talk:Binary_search_tree" rel="discussion" title="Discussion about the content page [t]" accesskey="t">Talk</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<ul class="menu">
													</ul>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="/wiki/Binary_search_tree">Read</a></span></li><li id="ca-edit" class="collapsible"><span><a href="/w/index.php?title=Binary_search_tree&amp;action=edit" title="Edit this page [e]" accesskey="e">Edit</a></span></li><li id="ca-history" class="collapsible"><span><a href="/w/index.php?title=Binary_search_tree&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<ul class="menu">
													</ul>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="/w/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Wikipedia" title="Search Wikipedia [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search Wikipedia for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page" title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li><li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li><li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content – the best of Wikipedia">Featured content</a></li><li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li><li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li><li id="n-sitesupport"><a href="https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikipedia.org&amp;uselang=en" title="Support us">Donate to Wikipedia</a></li><li id="n-shoplink"><a href="//shop.wikimedia.org" title="Visit the Wikipedia store">Wikipedia store</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-interaction" aria-labelledby="p-interaction-label">
			<h3 id="p-interaction-label">Interaction</h3>
			<div class="body">
								<ul>
					<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li><li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li><li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li><li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-contactpage"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact page</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Tools</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Binary_search_tree" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Binary_search_tree" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-upload"><a href="/wiki/Wikipedia:File_Upload_Wizard" title="Upload files [u]" accesskey="u">Upload file</a></li><li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-permalink"><a href="/w/index.php?title=Binary_search_tree&amp;oldid=881157393" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="/w/index.php?title=Binary_search_tree&amp;action=info" title="More information about this page">Page information</a></li><li id="t-wikibase"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q623818" title="Link to connected data repository item [g]" accesskey="g">Wikidata item</a></li><li id="t-cite"><a href="/w/index.php?title=Special:CiteThisPage&amp;page=Binary_search_tree&amp;id=881157393" title="Information on how to cite this page">Cite this page</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-coll-print_export" aria-labelledby="p-coll-print_export-label">
			<h3 id="p-coll-print_export-label">Print/export</h3>
			<div class="body">
								<ul>
					<li id="coll-create_a_book"><a href="/w/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=Binary+search+tree">Create a book</a></li><li id="coll-download-as-rdf2latex"><a href="/w/index.php?title=Special:ElectronPdf&amp;page=Binary+search+tree&amp;action=show-download-screen">Download as PDF</a></li><li id="t-print"><a href="/w/index.php?title=Binary_search_tree&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-wikibase-otherprojects" aria-labelledby="p-wikibase-otherprojects-label">
			<h3 id="p-wikibase-otherprojects-label">In other projects</h3>
			<div class="body">
								<ul>
					<li class="wb-otherproject-link wb-otherproject-commons"><a href="https://commons.wikimedia.org/wiki/Category:Binary_search_trees" hreflang="en">Wikimedia Commons</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-lang" aria-labelledby="p-lang-label">
			<h3 id="p-lang-label">Languages</h3>
			<div class="body">
								<ul>
					<li class="interlanguage-link interwiki-ar"><a href="https://ar.wikipedia.org/wiki/%D8%B4%D8%AC%D8%B1%D8%A9_%D8%A8%D8%AD%D8%AB_%D8%AB%D9%86%D8%A7%D8%A6%D9%8A%D8%A9" title="شجرة بحث ثنائية – Arabic" lang="ar" hreflang="ar" class="interlanguage-link-target">العربية</a></li><li class="interlanguage-link interwiki-bg"><a href="https://bg.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE_%D0%B4%D1%8A%D1%80%D0%B2%D0%BE_%D0%B7%D0%B0_%D1%82%D1%8A%D1%80%D1%81%D0%B5%D0%BD%D0%B5" title="Двоично дърво за търсене – Bulgarian" lang="bg" hreflang="bg" class="interlanguage-link-target">Български</a></li><li class="interlanguage-link interwiki-bs"><a href="https://bs.wikipedia.org/wiki/Binarno_stablo_pretra%C5%BEivanja" title="Binarno stablo pretraživanja – Bosnian" lang="bs" hreflang="bs" class="interlanguage-link-target">Bosanski</a></li><li class="interlanguage-link interwiki-ca"><a href="https://ca.wikipedia.org/wiki/Arbre_binari_de_cerca" title="Arbre binari de cerca – Catalan" lang="ca" hreflang="ca" class="interlanguage-link-target">Català</a></li><li class="interlanguage-link interwiki-cs"><a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_vyhled%C3%A1vac%C3%AD_strom" title="Binární vyhledávací strom – Czech" lang="cs" hreflang="cs" class="interlanguage-link-target">Čeština</a></li><li class="interlanguage-link interwiki-da"><a href="https://da.wikipedia.org/wiki/Bin%C3%A6rt_s%C3%B8getr%C3%A6" title="Binært søgetræ – Danish" lang="da" hreflang="da" class="interlanguage-link-target">Dansk</a></li><li class="interlanguage-link interwiki-de"><a href="https://de.wikipedia.org/wiki/Bin%C3%A4rer_Suchbaum" title="Binärer Suchbaum – German" lang="de" hreflang="de" class="interlanguage-link-target">Deutsch</a></li><li class="interlanguage-link interwiki-es"><a href="https://es.wikipedia.org/wiki/%C3%81rbol_binario_de_b%C3%BAsqueda" title="Árbol binario de búsqueda – Spanish" lang="es" hreflang="es" class="interlanguage-link-target">Español</a></li><li class="interlanguage-link interwiki-fa"><a href="https://fa.wikipedia.org/wiki/%D8%AF%D8%B1%D8%AE%D8%AA_%D8%AC%D8%B3%D8%AA%D8%AC%D9%88%DB%8C_%D8%AF%D9%88%D8%AF%D9%88%DB%8C%DB%8C" title="درخت جستجوی دودویی – Persian" lang="fa" hreflang="fa" class="interlanguage-link-target">فارسی</a></li><li class="interlanguage-link interwiki-fr"><a href="https://fr.wikipedia.org/wiki/Arbre_binaire_de_recherche" title="Arbre binaire de recherche – French" lang="fr" hreflang="fr" class="interlanguage-link-target">Français</a></li><li class="interlanguage-link interwiki-ko"><a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%83%90%EC%83%89_%ED%8A%B8%EB%A6%AC" title="이진 탐색 트리 – Korean" lang="ko" hreflang="ko" class="interlanguage-link-target">한국어</a></li><li class="interlanguage-link interwiki-id"><a href="https://id.wikipedia.org/wiki/Pohon_biner_terurut" title="Pohon biner terurut – Indonesian" lang="id" hreflang="id" class="interlanguage-link-target">Bahasa Indonesia</a></li><li class="interlanguage-link interwiki-it"><a href="https://it.wikipedia.org/wiki/Albero_binario_di_ricerca" title="Albero binario di ricerca – Italian" lang="it" hreflang="it" class="interlanguage-link-target">Italiano</a></li><li class="interlanguage-link interwiki-he"><a href="https://he.wikipedia.org/wiki/%D7%A2%D7%A5_%D7%97%D7%99%D7%A4%D7%95%D7%A9" title="עץ חיפוש – Hebrew" lang="he" hreflang="he" class="interlanguage-link-target">עברית</a></li><li class="interlanguage-link interwiki-nl"><a href="https://nl.wikipedia.org/wiki/Binaire_zoekboom" title="Binaire zoekboom – Dutch" lang="nl" hreflang="nl" class="interlanguage-link-target">Nederlands</a></li><li class="interlanguage-link interwiki-ja"><a href="https://ja.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2%E6%9C%A8" title="二分探索木 – Japanese" lang="ja" hreflang="ja" class="interlanguage-link-target">日本語</a></li><li class="interlanguage-link interwiki-pl"><a href="https://pl.wikipedia.org/wiki/Binarne_drzewo_poszukiwa%C5%84" title="Binarne drzewo poszukiwań – Polish" lang="pl" hreflang="pl" class="interlanguage-link-target">Polski</a></li><li class="interlanguage-link interwiki-pt"><a href="https://pt.wikipedia.org/wiki/%C3%81rvore_bin%C3%A1ria_de_busca" title="Árvore binária de busca – Portuguese" lang="pt" hreflang="pt" class="interlanguage-link-target">Português</a></li><li class="interlanguage-link interwiki-ro"><a href="https://ro.wikipedia.org/wiki/Arbore_binar_de_c%C4%83utare" title="Arbore binar de căutare – Romanian" lang="ro" hreflang="ro" class="interlanguage-link-target">Română</a></li><li class="interlanguage-link interwiki-ru"><a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0" title="Двоичное дерево поиска – Russian" lang="ru" hreflang="ru" class="interlanguage-link-target">Русский</a></li><li class="interlanguage-link interwiki-sk"><a href="https://sk.wikipedia.org/wiki/Bin%C3%A1rny_vyh%C4%BEad%C3%A1vac%C3%AD_strom" title="Binárny vyhľadávací strom – Slovak" lang="sk" hreflang="sk" class="interlanguage-link-target">Slovenčina</a></li><li class="interlanguage-link interwiki-sr"><a href="https://sr.wikipedia.org/wiki/Binarno_stablo_pretrage" title="Binarno stablo pretrage – Serbian" lang="sr" hreflang="sr" class="interlanguage-link-target">Српски / srpski</a></li><li class="interlanguage-link interwiki-fi"><a href="https://fi.wikipedia.org/wiki/Bin%C3%A4%C3%A4rinen_hakupuu" title="Binäärinen hakupuu – Finnish" lang="fi" hreflang="fi" class="interlanguage-link-target">Suomi</a></li><li class="interlanguage-link interwiki-sv"><a href="https://sv.wikipedia.org/wiki/Bin%C3%A4rt_s%C3%B6ktr%C3%A4d" title="Binärt sökträd – Swedish" lang="sv" hreflang="sv" class="interlanguage-link-target">Svenska</a></li><li class="interlanguage-link interwiki-th"><a href="https://th.wikipedia.org/wiki/%E0%B8%95%E0%B9%89%E0%B8%99%E0%B9%84%E0%B8%A1%E0%B9%89%E0%B8%84%E0%B9%89%E0%B8%99%E0%B8%AB%E0%B8%B2%E0%B9%81%E0%B8%9A%E0%B8%9A%E0%B8%97%E0%B8%A7%E0%B8%B4%E0%B8%A0%E0%B8%B2%E0%B8%84" title="ต้นไม้ค้นหาแบบทวิภาค – Thai" lang="th" hreflang="th" class="interlanguage-link-target">ไทย</a></li><li class="interlanguage-link interwiki-tr"><a href="https://tr.wikipedia.org/wiki/%C4%B0kili_arama_a%C4%9Fac%C4%B1" title="İkili arama ağacı – Turkish" lang="tr" hreflang="tr" class="interlanguage-link-target">Türkçe</a></li><li class="interlanguage-link interwiki-uk"><a href="https://uk.wikipedia.org/wiki/%D0%94%D0%B2%D1%96%D0%B9%D0%BA%D0%BE%D0%B2%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D1%88%D1%83%D0%BA%D1%83" title="Двійкове дерево пошуку – Ukrainian" lang="uk" hreflang="uk" class="interlanguage-link-target">Українська</a></li><li class="interlanguage-link interwiki-vi"><a href="https://vi.wikipedia.org/wiki/C%C3%A2y_t%C3%ACm_ki%E1%BA%BFm_nh%E1%BB%8B_ph%C3%A2n" title="Cây tìm kiếm nhị phân – Vietnamese" lang="vi" hreflang="vi" class="interlanguage-link-target">Tiếng Việt</a></li><li class="interlanguage-link interwiki-zh"><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" title="二元搜尋樹 – Chinese" lang="zh" hreflang="zh" class="interlanguage-link-target">中文</a></li>				</ul>
				<div class="after-portlet after-portlet-lang"><span class="wb-langlinks-edit wb-langlinks-link"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q623818#sitelinks-wikipedia" title="Edit interlanguage links" class="wbc-editpage">Edit links</a></span></div>			</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 31 January 2019, at 20:23<span class="anonymous-show">&#160;(UTC)</span>.</li>
								<li id="footer-info-copyright">Text is available under the <a rel="license" href="//en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a><a rel="license" href="//creativecommons.org/licenses/by-sa/3.0/" style="display:none;"></a>;
additional terms may apply.  By using this site, you agree to the <a href="//foundation.wikimedia.org/wiki/Terms_of_Use">Terms of Use</a> and <a href="//foundation.wikimedia.org/wiki/Privacy_policy">Privacy Policy</a>. Wikipedia® is a registered trademark of the <a href="//www.wikimediafoundation.org/">Wikimedia Foundation, Inc.</a>, a non-profit organization.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="https://foundation.wikimedia.org/wiki/Privacy_policy" class="extiw" title="wmf:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
								<li id="footer-places-disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-contact"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>
								<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Developers</a></li>
								<li id="footer-places-cookiestatement"><a href="https://foundation.wikimedia.org/wiki/Cookie_statement">Cookie statement</a></li>
								<li id="footer-places-mobileview"><a href="//en.m.wikipedia.org/w/index.php?title=Binary_search_tree&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="https://wikimediafoundation.org/"><img src="/static/images/wikimedia-button.png" srcset="/static/images/wikimedia-button-1.5x.png 1.5x, /static/images/wikimedia-button-2x.png 2x" width="88" height="31" alt="Wikimedia Foundation"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="//www.mediawiki.org/"><img src="/static/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/static/images/poweredby_mediawiki_132x47.png 1.5x, /static/images/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.416","walltime":"1.915","ppvisitednodes":{"value":2047,"limit":1000000},"ppgeneratednodes":{"value":0,"limit":1500000},"postexpandincludesize":{"value":65456,"limit":2097152},"templateargumentsize":{"value":4183,"limit":2097152},"expansiondepth":{"value":13,"limit":40},"expensivefunctioncount":{"value":0,"limit":500},"unstrip-depth":{"value":1,"limit":20},"unstrip-size":{"value":51542,"limit":5000000},"entityaccesscount":{"value":0,"limit":400},"timingprofile":["100.00% 1783.349      1 -total","  9.16%  163.381      2 Template:Reflist","  5.32%   94.791      4 Template:Cite_book","  4.51%   80.366      1 Template:Introduction_to_Algorithms","  3.79%   67.571      1 Template:Infobox_data_structure","  3.59%   63.992      1 Template:Infobox","  2.35%   41.930      8 Template:Cite_web","  2.20%   39.250      1 Template:ISBN","  1.68%   30.012      1 Template:Infobox3cols","  1.04%   18.571      3 Template:Main_article"]},"scribunto":{"limitreport-timeusage":{"value":"0.162","limit":"10.000"},"limitreport-memusage":{"value":4037372,"limit":52428800}},"cachereport":{"origin":"mw1248","timestamp":"20190203010559","ttl":2073600,"transientcontent":false}}});});</script>
<script type="application/ld+json">{"@context":"https:\/\/schema.org","@type":"Article","name":"Binary search tree","url":"https:\/\/en.wikipedia.org\/wiki\/Binary_search_tree","sameAs":"http:\/\/www.wikidata.org\/entity\/Q623818","mainEntity":"http:\/\/www.wikidata.org\/entity\/Q623818","author":{"@type":"Organization","name":"Contributors to Wikimedia projects"},"publisher":{"@type":"Organization","name":"Wikimedia Foundation, Inc.","logo":{"@type":"ImageObject","url":"https:\/\/www.wikimedia.org\/static\/images\/wmf-hor-googpub.png"}},"datePublished":"2001-10-29T21:04:42Z","dateModified":"2019-01-31T20:23:12Z","image":"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/d\/da\/Binary_search_tree.svg","headline":"data structure in tree form with 0, 1, or 2 children per node, sorted for fast lookup"}</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":172,"wgHostname":"mw1268"});});</script>
	</body>
</html>
