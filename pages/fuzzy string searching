<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Boyer–Moore string-search algorithm - Wikipedia</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Boyer–Moore_string-search_algorithm","wgTitle":"Boyer–Moore string-search algorithm","wgCurRevisionId":857560043,"wgRevisionId":857560043,"wgArticleId":684709,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Commons category link from Wikidata","Articles with example C code","Articles with example Python code","Articles with example Java code","String matching algorithms"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Boyer–Moore_string-search_algorithm","wgRelevantArticleId":684709,"wgRequestId":"XGZBMApAMFkAAJvDk4oAAAAX","wgCSPNonce":false,"wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"Boyer–Moore_string_search_algorithm","wgFlaggedRevsParams":{"tags":{}},"wgStableRevisionId":null,"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgWikiEditorEnabledModules":[],"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsShouldSendModuleToUser":true,"wgPopupsConflictsWithNavPopupGadget":false,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en","usePageImages":true,"usePageDescriptions":true},"wgMFIsPageContentModelEditable":true,"wgMFEnableFontChanger":true,"wgMFDisplayWikibaseDescriptions":{"search":true,"nearby":true,"watchlist":true,"tagline":false},"wgRelatedArticles":null,"wgRelatedArticlesUseCirrusSearch":true,"wgRelatedArticlesOnlyUseCirrusSearch":false,"wgWMESchemaEditAttemptStepOversample":false,"wgPoweredByHHVM":true,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralNoticeCookiesToDelete":[],"wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgInternalRedirectTargetUrl":"/wiki/Boyer%E2%80%93Moore_string-search_algorithm","wgWikibaseItemId":"Q895984","wgScoreNoteLanguages":{"arabic":"العربية","catalan":"català","deutsch":"Deutsch","english":"English","espanol":"español","italiano":"italiano","nederlands":"Nederlands","norsk":"norsk","portugues":"português","suomi":"suomi","svenska":"svenska","vlaams":"West-Vlams"},"wgScoreDefaultNoteLanguage":"nederlands","wgCentralAuthMobileDomain":false,"wgCodeMirrorEnabled":true,"wgVisualEditorToolbarScrollOffset":0,"wgVisualEditorUnsupportedEditParams":["undo","undoafter","veswitched"],"wgEditSubmitButtonLabelPublish":true,"oresWikiId":"enwiki","oresBaseUrl":"http://ores.discovery.wmnet:8081/","oresApiVersion":3});mw.loader.state({"ext.gadget.charinsert-styles":"ready","ext.globalCssJs.user.styles":"ready","ext.globalCssJs.site.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","ext.globalCssJs.user":"ready","ext.globalCssJs.site":"ready","user":"ready","user.options":"ready","user.tokens":"loading","ext.cite.styles":"ready","ext.math.styles":"ready","ext.pygments":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.toc.styles":"ready","wikibase.client.init":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","ext.3d.styles":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@0tffind",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});RLPAGEMODULES=["mediawiki.action.view.redirect","ext.cite.ux-enhancements","ext.math.scripts","site","mediawiki.page.startup","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.watchlist-notice","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","mmv.head","mmv.bootstrap.autostart","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging","ext.wikimediaEvents","ext.navigationTiming","ext.uls.eventlogger","ext.uls.init","ext.uls.compactlinks","ext.uls.interface","ext.quicksurveys.init","ext.centralNotice.geoIP","ext.centralNotice.startUp","skins.vector.js"];mw.loader.load(RLPAGEMODULES);});</script>
<link rel="stylesheet" href="/w/load.php?debug=false&amp;lang=en&amp;modules=ext.3d.styles%7Cext.cite.styles%7Cext.math.styles%7Cext.pygments%2CwikimediaBadges%7Cext.uls.interlanguage%7Cext.visualEditor.desktopArticleTarget.noscript%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.toc.styles%7Cskins.vector.styles%7Cwikibase.client.init&amp;only=styles&amp;skin=vector"/>
<script async="" src="/w/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/w/load.php?debug=false&amp;lang=en&amp;modules=ext.gadget.charinsert-styles&amp;only=styles&amp;skin=vector"/>
<link rel="stylesheet" href="/w/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.33.0-wmf.17"/>
<meta name="referrer" content="origin"/>
<meta name="referrer" content="origin-when-crossorigin"/>
<meta name="referrer" content="origin-when-cross-origin"/>
<link rel="alternate" href="android-app://org.wikipedia/http/en.m.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm"/>
<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit"/>
<link rel="edit" title="Edit this page" href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit"/>
<link rel="apple-touch-icon" href="/static/apple-touch/wikipedia.png"/>
<link rel="shortcut icon" href="/static/favicon/wikipedia.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd"/>
<link rel="license" href="//creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="canonical" href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm"/>
<link rel="dns-prefetch" href="//login.wikimedia.org"/>
<link rel="dns-prefetch" href="//meta.wikimedia.org" />
<!--[if lt IE 9]><script src="/w/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-Boyer–Moore_string-search_algorithm rootpage-Boyer–Moore_string-search_algorithm skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><!-- CentralNotice --></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Boyer–Moore string-search algorithm</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Wikipedia, the free encyclopedia</div>				<div id="contentSub"><span class="mw-redirectedfrom">&#160;&#160;(Redirected from <a href="/w/index.php?title=Boyer%E2%80%93Moore_string_search_algorithm&amp;redirect=no" class="mw-redirect" title="Boyer–Moore string search algorithm">Boyer–Moore string search algorithm</a>)</span></div>
				<div id="jump-to-nav"></div>				<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
				<a class="mw-jump-link" href="#p-search">Jump to search</a>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div role="note" class="hatnote navigation-not-searchable">For the Boyer-Moore theorem prover, see <a href="/wiki/Nqthm" title="Nqthm">Nqthm</a>.</div>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, the <b>Boyer–Moore string-search algorithm</b> is an efficient <a href="/wiki/String-searching_algorithm" title="String-searching algorithm">string-searching algorithm</a> that is the standard benchmark for practical string-search literature.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">&#91;1&#93;</a></sup> It was developed by <a href="/wiki/Robert_S._Boyer" title="Robert S. Boyer">Robert S. Boyer</a> and <a href="/wiki/J_Strother_Moore" title="J Strother Moore">J Strother Moore</a> in 1977.<sup id="cite_ref-original_2-0" class="reference"><a href="#cite_note-original-2">&#91;2&#93;</a></sup> The <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> <a href="/wiki/Preprocessor" title="Preprocessor">preprocesses</a> the <a href="/wiki/String_(computer_science)" title="String (computer science)">string</a> being searched for (the pattern), but not the string being searched in (the text). It is thus well-suited for applications in which the pattern is much shorter than the text or where it persists across multiple searches. The Boyer-Moore algorithm uses information gathered during the preprocess step to skip sections of the text, resulting in a lower constant factor than many other string search algorithms. In general, the algorithm runs faster as the pattern length increases. The key features of the algorithm are to match on the tail of the pattern rather than the head, and to skip along the text in jumps of multiple characters rather than searching every single character in the text.
</p>
<div id="toc" class="toc"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Definitions"><span class="tocnumber">1</span> <span class="toctext">Definitions</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Description"><span class="tocnumber">2</span> <span class="toctext">Description</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Shift_Rules"><span class="tocnumber">3</span> <span class="toctext">Shift Rules</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#The_Bad_Character_Rule"><span class="tocnumber">3.1</span> <span class="toctext">The Bad Character Rule</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Description_2"><span class="tocnumber">3.1.1</span> <span class="toctext">Description</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Preprocessing"><span class="tocnumber">3.1.2</span> <span class="toctext">Preprocessing</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-7"><a href="#The_Good_Suffix_Rule"><span class="tocnumber">3.2</span> <span class="toctext">The Good Suffix Rule</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#Description_3"><span class="tocnumber">3.2.1</span> <span class="toctext">Description</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Preprocessing_2"><span class="tocnumber">3.2.2</span> <span class="toctext">Preprocessing</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#The_Galil_Rule"><span class="tocnumber">4</span> <span class="toctext">The Galil Rule</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Performance"><span class="tocnumber">5</span> <span class="toctext">Performance</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Implementations"><span class="tocnumber">6</span> <span class="toctext">Implementations</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Variants"><span class="tocnumber">7</span> <span class="toctext">Variants</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Definitions">Definitions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=1" title="Edit section: Definitions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="thumb tright" style="width:160px;">
<div>
<table>
<tbody><tr>
<td>A</td>
<td>N</td>
<td>P</td>
<td>A</td>
<td>N</td>
<td>M</td>
<td>A</td>
<td>N</td>
<td>-
</td></tr>
<tr>
<td>P</td>
<td>A</td>
<td>N</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>P</td>
<td>A</td>
<td>N</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>-</td>
<td>P</td>
<td>A</td>
<td>N</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>P</td>
<td>A</td>
<td>N</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>P</td>
<td>A</td>
<td>N</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>P</td>
<td>A</td>
<td>N</td>
<td>-
</td></tr></tbody></table>
<div class="thumbcaption" style="width:160px;">Alignments of pattern <b>PAN</b> to text <b>ANPANMAN</b>, from <b>k=3</b> to <b>k=8</b>. A match occurs at <b>k=5</b>.</div>
</div>
</div>
<ul><li><b><i>S</i>[<i>i</i>]</b> denotes the character at index <i>i</i> of string <i>S</i>, counting from 1.</li>
<li><b><i>S</i>[<i>i</i>..<i>j</i>]</b> denotes the <a href="/wiki/Substring" title="Substring">substring</a> of string <i>S</i> starting at index <i>i</i> and ending at <i>j</i>, inclusive.</li>
<li>A <i>prefix</i> of <i>S</i> is a substring <i>S</i>[1..<i>i</i>] for some <i>i</i> in range [1, <i>n</i>], where <i>n</i> is the length of <i>S</i>.</li>
<li>A <i>suffix</i> of <i>S</i> is a substring <i>S</i>[<i>i</i>..<i>n</i>] for some <i>i</i> in range [1, <i>n</i>], where <i>n</i> is the length of <i>S</i>.</li>
<li>The string to be searched for is called the <i>pattern</i> and is denoted by <i><b>P</b></i>. Its length is <i><b>n</b></i>.</li>
<li>The string being searched in is called the <i>text</i> and is denoted by <i><b>T</b></i>. Its length is <i><b>m</b></i>.</li>
<li>An <i>alignment</i> of <i>P</i> to <i>T</i> is an index <i>k</i> in <i>T</i> such that the last character of <i>P</i> is aligned with index <i>k</i> of <i>T</i>.</li>
<li>A <i>match</i> or <i>occurrence</i> of <i>P</i> occurs at an alignment if <i>P</i> is equivalent to <i>T</i>[(<i>k</i>-<i>n</i>+1)..<i>k</i>].</li></ul>
<h2><span class="mw-headline" id="Description">Description</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=2" title="Edit section: Description">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Boyer-Moore algorithm searches for occurrences of <span class="texhtml mvar" style="font-style:italic;">P</span> in <span class="texhtml mvar" style="font-style:italic;">T</span> by performing explicit character comparisons at different alignments. Instead of a <a href="/wiki/Brute-force_search" title="Brute-force search">brute-force search</a> of all alignments (of which there are <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle m-n+1}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>m</mi>
        <mo>&#x2212;<!-- − --></mo>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle m-n+1}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bfbb66560172d28059ea3303617bcffdb4eda01a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.505ex; width:10.278ex; height:2.343ex;" alt="m-n+1"/></span>), Boyer-Moore uses information gained by preprocessing <span class="texhtml mvar" style="font-style:italic;">P</span> to skip as many alignments as possible.
</p><p>Previous to the introduction of this algorithm, the usual way to search within text was to examine each character of the text for the first character of the pattern. Once that was found the subsequent characters of the text would be compared to the characters of the pattern. If no match occurred then the text would again be checked character by character in an effort to find a match. Thus almost every character in the text needs to be examined.
</p><p>The key insight in this algorithm is that if the end of the pattern is compared to the text, then jumps along the text can be made rather than checking every character of the text. The reason that this works is that in lining up the pattern against the text, the last character of the pattern is compared to the character in the text. If the characters do not match, there is no need to continue searching backwards along the text. If the character in the text does not match any of the characters in the pattern, then the next character in the text to check is located <span class="texhtml mvar" style="font-style:italic;">n</span> characters farther along the text, where <span class="texhtml mvar" style="font-style:italic;">n</span> is the length of the pattern. If the character in the text <i>is</i> in the pattern, then a partial shift of the pattern along the text is done to line up along the matching character and the process is repeated. Jumping along the text to make comparisons rather than checking every character in the text decreases the number of comparisons that have to be made, which is the key to the efficiency of the algorithm.
</p><p>More formally, the algorithm begins at alignment <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle k=n}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>k</mi>
        <mo>=</mo>
        <mi>n</mi>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle k=n}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c4b8cc6fcba0c0b24656b0fb33414d2e6cffb83c" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.338ex; width:5.704ex; height:2.176ex;" alt="k=n"/></span>, so the start of <span class="texhtml mvar" style="font-style:italic;">P</span> is aligned with the start of <span class="texhtml mvar" style="font-style:italic;">T</span>. Characters in <span class="texhtml mvar" style="font-style:italic;">P</span> and <span class="texhtml mvar" style="font-style:italic;">T</span> are then compared starting at index <span class="texhtml mvar" style="font-style:italic;">n</span> in <span class="texhtml mvar" style="font-style:italic;">P</span> and <span class="texhtml mvar" style="font-style:italic;">k</span> in <span class="texhtml mvar" style="font-style:italic;">T</span>, moving backward. The strings are matched from the end of <span class="texhtml mvar" style="font-style:italic;">P</span> to the start of <span class="texhtml mvar" style="font-style:italic;">P</span>. The comparisons continue until either the beginning of <span class="texhtml mvar" style="font-style:italic;">P</span> is reached (which means there is a match) or a mismatch occurs upon which the alignment is shifted forward (to the right) according to the maximum value permitted by a number of rules. The comparisons are performed again at the new alignment, and the process repeats until the alignment is shifted past the end of <span class="texhtml mvar" style="font-style:italic;">T</span>, which means no further matches will be found.
</p><p>The shift rules are implemented as constant-time table lookups, using tables generated during the preprocessing of <span class="texhtml mvar" style="font-style:italic;">P</span>.
</p>
<h2><span class="mw-headline" id="Shift_Rules">Shift Rules</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=3" title="Edit section: Shift Rules">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A shift is calculated by applying two rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules. 
</p>
<h3><span class="mw-headline" id="The_Bad_Character_Rule">The Bad Character Rule</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=4" title="Edit section: The Bad Character Rule">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="Description_2">Description</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=5" title="Edit section: Description">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="thumb tright" style="width:160px;">
<div>
<table>
<tbody><tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>X</td>
<td>-</td>
<td>-</td>
<td>K</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>A</td>
<td>N</td>
<td>P</td>
<td>A</td>
<td><span style="color:#FF0000">N</span></td>
<td>M</td>
<td>A</td>
<td>N</td>
<td>A</td>
<td>M</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>N</td>
<td><span style="color:#0000FF">N</span></td>
<td>A</td>
<td>A</td>
<td>M</td>
<td>A</td>
<td>N</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>N</td>
<td><span style="color:#0000FF">N</span></td>
<td>A</td>
<td>A</td>
<td>M</td>
<td>A</td>
<td>N</td>
<td>-
</td></tr></tbody></table>
<div class="thumbcaption" style="width:160px;">Demonstration of bad character rule with pattern <b>NNAAMAN</b>.</div>
</div>
</div>
<p>The bad-character rule considers the character in <span class="texhtml mvar" style="font-style:italic;">T</span> at which the comparison process failed (assuming such a failure occurred). The next occurrence of that character to the left in <span class="texhtml mvar" style="font-style:italic;">P</span> is found, and a shift which brings that occurrence in line with the mismatched occurrence in <span class="texhtml mvar" style="font-style:italic;">T</span> is proposed. If the mismatched character does not occur to the left in <span class="texhtml mvar" style="font-style:italic;">P</span>, a shift is proposed that moves the entirety of <span class="texhtml mvar" style="font-style:italic;">P</span> past the point of mismatch.
</p>
<h4><span class="mw-headline" id="Preprocessing">Preprocessing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=6" title="Edit section: Preprocessing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Methods vary on the exact form the table for the bad character rule should take, but a simple constant-time lookup solution is as follows: create a 2D table which is indexed first by the index of the character <span class="texhtml mvar" style="font-style:italic;">c</span> in the alphabet and second by the index <span class="texhtml mvar" style="font-style:italic;">i</span> in the pattern. This lookup will return the occurrence of <span class="texhtml mvar" style="font-style:italic;">c</span> in <span class="texhtml mvar" style="font-style:italic;">P</span> with the next-highest index <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle j&lt;i}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>j</mi>
        <mo>&lt;</mo>
        <mi>i</mi>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle j&lt;i}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/49a18ef9f535c9ff19683360978ab4550c92d4d1" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.671ex; margin-left: -0.027ex; width:4.886ex; height:2.509ex;" alt="j&lt;i"/></span> or -1 if there is no such occurrence. The proposed shift will then be <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle i-j}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>i</mi>
        <mo>&#x2212;<!-- − --></mo>
        <mi>j</mi>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle i-j}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2c78f9458ea63e9d74a5d753f8f093de91d3f74b" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.671ex; width:4.601ex; height:2.509ex;" alt="i-j"/></span>, with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(1)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(1)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:4.745ex; height:2.843ex;" alt="O(1)"/></span> lookup time and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(kn)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(kn)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6ef610f176fc2b47d4e52605ae0a86d0a16cb67f" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:6.189ex; height:2.843ex;" alt="O(kn)"/></span> space, assuming a finite alphabet of length <span class="texhtml mvar" style="font-style:italic;">k</span>.
</p>
<h3><span class="mw-headline" id="The_Good_Suffix_Rule">The Good Suffix Rule</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=7" title="Edit section: The Good Suffix Rule">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="Description_3">Description</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=8" title="Edit section: Description">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="thumb tright" style="width:200px;">
<div>
<table>
<tbody><tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>X</td>
<td>-</td>
<td>-</td>
<td>K</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>M</td>
<td>A</td>
<td>N</td>
<td>P</td>
<td>A</td>
<td><span style="color:#0000FF">N</span></td>
<td><span style="color:#0000FF">A</span></td>
<td><span style="color:#0000FF">M</span></td>
<td>A</td>
<td>N</td>
<td>A</td>
<td>P</td>
<td>-
</td></tr>
<tr>
<td>A</td>
<td><span style="color:#FF0000">N</span></td>
<td><span style="color:#FF0000">A</span></td>
<td><span style="color:#FF0000">M</span></td>
<td>P</td>
<td><span style="color:#0000FF">N</span></td>
<td><span style="color:#0000FF">A</span></td>
<td><span style="color:#0000FF">M</span></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-
</td></tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>A</td>
<td><span style="color:#FF0000">N</span></td>
<td><span style="color:#FF0000">A</span></td>
<td><span style="color:#FF0000">M</span></td>
<td>P</td>
<td>N</td>
<td>A</td>
<td>M</td>
<td>-
</td></tr></tbody></table>
<div class="thumbcaption" style="width:200px;">Demonstration of good suffix rule with pattern <b>ANAMPNAM</b>.</div>
</div>
</div>
<p>The good suffix rule is markedly more complex in both concept and implementation than the bad character rule. It is the reason comparisons begin at the end of the pattern rather than the start, and is formally stated thus:<sup id="cite_ref-ASTS_3-0" class="reference"><a href="#cite_note-ASTS-3">&#91;3&#93;</a></sup>
</p>
<blockquote>
<p>Suppose for a given alignment of <i><b>P</b></i> and <i><b>T</b></i>, a substring <i><b>t</b></i> of <i><b>T</b></i> matches a suffix of <i><b>P</b></i>, but a mismatch occurs at the next comparison to the left. Then find, if it exists, the right-most copy <i><b>t'</b></i> of <i><b>t</b></i> in <i><b>P</b></i> such that <i><b>t'</b></i> is not a suffix of <i><b>P</b></i> and the character to the left of <i><b>t'</b></i> in <i><b>P</b></i> differs from the character to the left of <i><b>t</b></i> in <i><b>P</b></i>. Shift <i><b>P</b></i> to the right so that substring <i><b>t'</b></i> in <i><b>P</b></i> aligns with substring <i><b>t</b></i> in <i><b>T</b></i>. If <i><b>t'</b></i> does not exist, then shift the left end of <i><b>P</b></i> past the left end of <i><b>t</b></i> in <i><b>T</b></i> by the least amount so that a prefix of the shifted pattern matches a suffix of <i><b>t</b></i> in <i><b>T</b></i>. If no such shift is possible, then shift <i><b>P</b></i> by <i><b>n</b></i> places to the right. If an occurrence of <i><b>P</b></i> is found, then shift <i><b>P</b></i> by the least amount so that a <i>proper</i> prefix of the shifted <i><b>P</b></i> matches a suffix of the occurrence of <i><b>P</b></i> in <i><b>T</b></i>. If no such shift is possible, then shift <i><b>P</b></i> by <i><b>n</b></i> places, that is, shift <i><b>P</b></i> past <i><b>t</b></i>.
</p>
</blockquote>
<h4><span class="mw-headline" id="Preprocessing_2">Preprocessing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=9" title="Edit section: Preprocessing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The good suffix rule requires two tables: one for use in the general case, and another for use when either the general case returns no meaningful result or a match occurs. These tables will be designated <span class="texhtml mvar" style="font-style:italic;">L</span> and <span class="texhtml mvar" style="font-style:italic;">H</span> respectively. Their definitions are as follows:<sup id="cite_ref-ASTS_3-1" class="reference"><a href="#cite_note-ASTS-3">&#91;3&#93;</a></sup>
</p>
<blockquote>
<p>For each <span class="texhtml mvar" style="font-style:italic;">i</span>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle L[i]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>L</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle L[i]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f505bfd1424f010a620a5a78e2f175653949230c" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:3.679ex; height:2.843ex;" alt="L[i]"/></span> is the largest position less than <span class="texhtml mvar" style="font-style:italic;">n</span> such that string <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle P[i..n]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>P</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo>.</mo>
        <mo>.</mo>
        <mi>n</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle P[i..n]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db3179eb72b3124f39c39a3d781c47bf1e26daac" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:7.304ex; height:2.843ex;" alt="P[i..n]"/></span> matches a suffix of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle P[1..L[i]]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>P</mi>
        <mo stretchy="false">[</mo>
        <mn>1..</mn>
        <mi>L</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle P[1..L[i]]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8ab9c5431f611e9b3d65a8385c6fecbbe2b7402c" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:9.174ex; height:2.843ex;" alt="P[1..L[i]]"/></span> and such that the character preceding that suffix is not equal to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle P[i-1]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>P</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo>&#x2212;<!-- − --></mo>
        <mn>1</mn>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle P[i-1]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/684dd0cf230387708cb8a649188c273134e8b10d" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:7.844ex; height:2.843ex;" alt="P[i-1]"/></span>. <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle L[i]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>L</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle L[i]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f505bfd1424f010a620a5a78e2f175653949230c" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:3.679ex; height:2.843ex;" alt="L[i]"/></span> is defined to be zero if there is no position satisfying the condition.
</p>
</blockquote>
<blockquote>
<p>Let <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle H[i]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>H</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle H[i]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e0d1e646ae278fb8ce6fc87c85e9cf2f61fcd0" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:4.16ex; height:2.843ex;" alt="H[i]"/></span> denote the length of the largest suffix of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle P[i..n]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>P</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo>.</mo>
        <mo>.</mo>
        <mi>n</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle P[i..n]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db3179eb72b3124f39c39a3d781c47bf1e26daac" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:7.304ex; height:2.843ex;" alt="P[i..n]"/></span> that is also a prefix of <span class="texhtml mvar" style="font-style:italic;">P</span>, if one exists. If none exists, let <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle H[i]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>H</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle H[i]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e0d1e646ae278fb8ce6fc87c85e9cf2f61fcd0" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:4.16ex; height:2.843ex;" alt="H[i]"/></span> be zero.
</p>
</blockquote>
<p>Both of these tables are constructible in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(n)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(n)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:4.977ex; height:2.843ex;" alt="O(n)"/></span> time and use <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(n)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(n)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:4.977ex; height:2.843ex;" alt="O(n)"/></span> space. The alignment shift for index <span class="texhtml mvar" style="font-style:italic;">i</span> in <span class="texhtml mvar" style="font-style:italic;">P</span> is given by <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle n-L[i]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>n</mi>
        <mo>&#x2212;<!-- − --></mo>
        <mi>L</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle n-L[i]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cc4e8398110e727ecc2a7aa5f9725eda4ae716e3" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:7.914ex; height:2.843ex;" alt="n-L[i]"/></span> or <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle n-H[i]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>n</mi>
        <mo>&#x2212;<!-- − --></mo>
        <mi>H</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle n-H[i]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2aa276517f98902dacacc36ded817eca08214a64" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:8.395ex; height:2.843ex;" alt="n-H[i]"/></span>. <span class="texhtml mvar" style="font-style:italic;">H</span> should only be used if <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle L[i]}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>L</mi>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle L[i]}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f505bfd1424f010a620a5a78e2f175653949230c" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:3.679ex; height:2.843ex;" alt="L[i]"/></span> is zero or a match has been found.
</p>
<h2><span class="mw-headline" id="The_Galil_Rule">The Galil Rule</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=10" title="Edit section: The Galil Rule">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A simple but important optimization of Boyer-Moore was put forth by <a href="/wiki/Zvi_Galil" title="Zvi Galil">Galil</a> in 1979.<sup id="cite_ref-galill_4-0" class="reference"><a href="#cite_note-galill-4">&#91;4&#93;</a></sup>
As opposed to shifting, the Galil rule deals with speeding up the actual comparisons done at each alignment by skipping sections that are known to match. Suppose that at an alignment <span class="texhtml"><i>k</i><sub>1</sub></span>, <span class="texhtml"><i><b>P</b></i></span> is compared with <span class="texhtml"><i><b>T</b></i></span> down to character <span class="texhtml"><i><b>c</b></i></span> of <span class="texhtml"><i><b>T</b></i></span>. Then if <span class="texhtml"><i><b>P</b></i></span> is shifted to <span class="texhtml"><i>k</i><sub>2</sub></span> such that its left end is between <span class="texhtml"><i><b>c</b></i></span> and <span class="texhtml"><i>k</i><sub>1</sub></span>, in the next comparison phase a prefix of <span class="texhtml"><i><b>P</b></i></span> must match the substring <span class="texhtml"><i><b>T</b></i>[(<i>k</i><sub>2</sub> - <i>n</i>)..<i>k</i><sub>1</sub>]</span>. Thus if the comparisons get down to position <span class="texhtml"><i>k</i><sub>1</sub></span> of <span class="texhtml"><i><b>T</b></i></span>, an occurrence of <span class="texhtml"><i><b>P</b></i></span> can be recorded without explicitly comparing past <span class="texhtml"><i>k</i><sub>1</sub></span>. In addition to increasing the efficiency of Boyer-Moore, the Galil rule is required for proving linear-time execution in the worst case.
</p>
<h2><span class="mw-headline" id="Performance">Performance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=11" title="Edit section: Performance">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Boyer-Moore algorithm as presented in the original paper has worst-case running time of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(n+m)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo>+</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(n+m)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5d103b38ce2abfde793118c89cd4fac5c956b89d" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:9.858ex; height:2.843ex;" alt="O(n+m)"/></span> only if the pattern does <i>not</i> appear in the text. This was first proved by <a href="/wiki/Donald_Knuth" title="Donald Knuth">Knuth</a>, <a href="/wiki/James_H._Morris" title="James H. Morris">Morris</a>, and <a href="/wiki/Vaughan_Pratt" title="Vaughan Pratt">Pratt</a> in 1977,<sup id="cite_ref-kmp_5-0" class="reference"><a href="#cite_note-kmp-5">&#91;5&#93;</a></sup>
followed by <a href="/wiki/Leonidas_J._Guibas" title="Leonidas J. Guibas">Guibas</a> and <a href="/wiki/Andrew_Odlyzko" title="Andrew Odlyzko">Odlyzko</a> in 1980<sup id="cite_ref-go_6-0" class="reference"><a href="#cite_note-go-6">&#91;6&#93;</a></sup> with an upper bound of <span class="texhtml">5<i>n</i></span> comparisons in the worst case. Richard Cole gave a proof with an upper bound of <span class="texhtml">3<i>n</i></span> comparisons in the worst case in 1991.<sup id="cite_ref-cole_7-0" class="reference"><a href="#cite_note-cole-7">&#91;7&#93;</a></sup>
</p><p>When the pattern <i>does</i> occur in the text, running time of the original algorithm is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(nm)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(nm)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/051245e657739f572fe7902c817ea9103c687fb7" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:7.018ex; height:2.843ex;" alt="O(nm)"/></span> in the worst case. This is easy to see when both pattern and text consist solely of the same repeated character. However, inclusion of the <a href="/wiki/Boyer%E2%80%93Moore_string_search_algorithm#The_Galil_Rule" class="mw-redirect" title="Boyer–Moore string search algorithm">Galil rule</a> results in linear runtime across all cases.<sup id="cite_ref-galill_4-1" class="reference"><a href="#cite_note-galill-4">&#91;4&#93;</a></sup><sup id="cite_ref-cole_7-1" class="reference"><a href="#cite_note-cole-7">&#91;7&#93;</a></sup>
</p>
<h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=12" title="Edit section: Implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Various implementations exist in different programming languages. In <a href="/wiki/C%2B%2B" title="C++">C++</a>, <a href="/wiki/Boost_(C%2B%2B_libraries)" title="Boost (C++ libraries)">Boost</a> provides the <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/1_58_0/libs/algorithm/doc/html/algorithm/Searching.html#the_boost_algorithm_library.Searching.BoyerMoore">generic Boyer–Moore search</a> implementation under the <i>Algorithm</i> library. In <a href="/wiki/Go_(programming_language)" title="Go (programming language)">Go (programming language)</a> there is an implementation in <a rel="nofollow" class="external text" href="https://golang.org/src/strings/search.go">search.go</a>. <a href="/wiki/D_(programming_language)" title="D (programming language)">D (programming language)</a> uses a <a rel="nofollow" class="external text" href="http://dlang.org/phobos/std_algorithm_searching.html#boyerMooreFinder">BoyerMooreFinder</a> for predicate based matching within ranges as a part of the Phobos Runtime Library.
</p><p>The Boyer-Moore algorithm is also used in <a href="/wiki/GNU" title="GNU">GNU</a>'s <a href="/wiki/Grep" title="Grep">grep</a>.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8">&#91;8&#93;</a></sup>
</p><p>Below are a few simple implementations.
</p>
<div class="NavFrame collapsed">
<div class="NavHead">[Python implementation]</div>
<div class="NavContent">
<div style="text-align:left">
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="k">def</span> <span class="nf">alphabet_index</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the index of the given character in the English alphabet, counting from 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="o">-</span> <span class="mi">97</span> <span class="c1"># &#39;a&#39; is ASCII character 97</span>

<span class="k">def</span> <span class="nf">match_length</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the length of the match of the substrings of S beginning at idx1 and idx2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">idx1</span> <span class="o">==</span> <span class="n">idx2</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">-</span> <span class="n">idx1</span>
    <span class="n">match_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="ow">and</span> <span class="n">S</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">idx2</span><span class="p">]:</span>
        <span class="n">match_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">idx1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">idx2</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">match_count</span>

<span class="k">def</span> <span class="nf">fundamental_preprocess</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns Z, the Fundamental Preprocessing of S. Z[i] is the length of the substring </span>
<span class="sd">    beginning at i which is also a prefix of S. This pre-processing is done in O(n) time,</span>
<span class="sd">    where n is the length of S.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handles case of empty string</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Handles case of single-character string</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span>
    <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_length</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># Optimization from exercise 1-5</span>
        <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="c1"># Defines lower and upper limits of z-box</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span> <span class="c1"># i falls within existing z-box</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">l</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">:</span> <span class="c1"># b ends within existing z-box</span>
                <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># b ends at or after the end of the z-box, we need to do an explicit match to the right of the z-box</span>
                <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">match_length</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># i does not reside within existing z-box</span>
            <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_length</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">z</span>

<span class="k">def</span> <span class="nf">bad_character_table</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates R for S, which is an array indexed by the position of some character c in the </span>
<span class="sd">    English alphabet. At that index in R is an array of length |S|+1, specifying for each</span>
<span class="sd">    index i in S (plus the index after S) the next location of character c encountered when</span>
<span class="sd">    traversing S from right to left starting at i. This is used for a constant-time lookup</span>
<span class="sd">    for the bad character rule in the Boyer-Moore string search algorithm, although it has</span>
<span class="sd">    a much larger size than non-constant-time solutions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">)]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">)]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="n">alpha</span><span class="p">[</span><span class="n">alphabet_index</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
            <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span>

<span class="k">def</span> <span class="nf">good_suffix_table</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates L for S, an array used in the implementation of the strong good suffix rule.</span>
<span class="sd">    L[i] = k, the largest position in S such that S[i:] (the suffix of S starting at i) matches</span>
<span class="sd">    a suffix of S[:k] (a substring in S ending at k). Used in Boyer-Moore, L gives an amount to</span>
<span class="sd">    shift P relative to T such that no instances of P in T are skipped and a suffix of P[:L[i]]</span>
<span class="sd">    matches the substring of T matched by a suffix of P in the previous match attempt.</span>
<span class="sd">    Specifically, if the mismatch took place at position i-1 in P, the shift magnitude is given</span>
<span class="sd">    by the equation len(P) - L[i]. In the case that L[i] = -1, the full shift table is used.</span>
<span class="sd">    Since only proper suffixes matter, L[0] = -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">fundamental_preprocess</span><span class="p">(</span><span class="n">S</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># S[::-1] reverses S</span>
    <span class="n">N</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">-</span> <span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
    <span class="k">return</span> <span class="n">L</span>

<span class="k">def</span> <span class="nf">full_shift_table</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates F for S, an array used in a special case of the good suffix rule in the Boyer-Moore</span>
<span class="sd">    string search algorithm. F[i] is the length of the longest suffix of S[i:] that is also a</span>
<span class="sd">    prefix of S. In the cases it is used, the shift magnitude of the pattern P relative to the</span>
<span class="sd">    text T is len(P) - F[i] for a mismatch occurring at i-1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">fundamental_preprocess</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">zv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">Z</span><span class="p">)):</span>
        <span class="n">longest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">longest</span><span class="p">)</span> <span class="k">if</span> <span class="n">zv</span> <span class="o">==</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">else</span> <span class="n">longest</span>
        <span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">longest</span>
    <span class="k">return</span> <span class="n">F</span>

<span class="k">def</span> <span class="nf">string_search</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the Boyer-Moore string search algorithm. This finds all occurrences of P</span>
<span class="sd">    in T, and incorporates numerous ways of pre-processing the pattern to determine the optimal </span>
<span class="sd">    amount to shift the string and skip comparisons. In practice it runs in O(m) (and even </span>
<span class="sd">    sublinear) time, where m is the length of T. This implementation performs a case-insensitive</span>
<span class="sd">    search on ASCII alphabetic characters, spaces not included.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Preprocessing</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">bad_character_table</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">good_suffix_table</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">full_shift_table</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>      <span class="c1"># Represents alignment of end of P relative to T</span>
    <span class="n">previous_k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>     <span class="c1"># Represents alignment in previous phase (Galil&#39;s rule)</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Character to compare in P</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">k</span>           <span class="c1"># Character to compare in T</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">previous_k</span> <span class="ow">and</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">T</span><span class="p">[</span><span class="n">h</span><span class="p">]:</span>   <span class="c1"># Matches starting from end of P</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">h</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">h</span> <span class="o">==</span> <span class="n">previous_k</span><span class="p">:</span>  <span class="c1"># Match has been found (Galil&#39;s rule)</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># No match, shift by max of bad character and good suffix rules</span>
            <span class="n">char_shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="n">alphabet_index</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">h</span><span class="p">])][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>   <span class="c1"># Mismatch happened on first attempt</span>
                <span class="n">suffix_shift</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>   <span class="c1"># Matched suffix does not appear anywhere in P</span>
                <span class="n">suffix_shift</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>               <span class="c1"># Matched suffix appears in P</span>
                <span class="n">suffix_shift</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">char_shift</span><span class="p">,</span> <span class="n">suffix_shift</span><span class="p">)</span>
            <span class="n">previous_k</span> <span class="o">=</span> <span class="n">k</span> <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">else</span> <span class="n">previous_k</span>  <span class="c1"># Galil&#39;s rule</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="n">shift</span>
    <span class="k">return</span> <span class="n">matches</span>
</pre></div>
</div>
</div>
</div>
<div class="NavFrame collapsed">
<div class="NavHead">[C implementation]</div>
<div class="NavContent">
<div style="text-align:left">
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define ALPHABET_LEN 256</span>
<span class="cp">#define NOT_FOUND patlen</span>
<span class="cp">#define max(a, b) ((a &lt; b) ? b : a)</span>

<span class="c1">// delta1 table: delta1[c] contains the distance between the last</span>
<span class="c1">// character of pat and the rightmost occurrence of c in pat.</span>
<span class="c1">// If c does not occur in pat, then delta1[c] = patlen.</span>
<span class="c1">// If c is at string[i] and c != pat[patlen-1], we can</span>
<span class="c1">// safely shift i over by delta1[c], which is the minimum distance</span>
<span class="c1">// needed to shift pat forward to get string[i] lined up </span>
<span class="c1">// with some character in pat.</span>
<span class="c1">// this algorithm runs in alphabet_len+patlen time.</span>
<span class="kt">void</span> <span class="nf">make_delta1</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">delta1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pat</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">patlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ALPHABET_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delta1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOT_FOUND</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delta1</span><span class="p">[</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// true if the suffix of word starting from word[pos] is a prefix </span>
<span class="c1">// of word</span>
<span class="kt">int</span> <span class="nf">is_prefix</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wordlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">suffixlen</span> <span class="o">=</span> <span class="n">wordlen</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>
    <span class="c1">// could also use the strncmp() library function here</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">suffixlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// length of the longest suffix of word ending on word[pos].</span>
<span class="c1">// suffix_length(&quot;dddbcabc&quot;, 8, 4) = 2</span>
<span class="kt">int</span> <span class="nf">suffix_length</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wordlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="c1">// increment suffix length i to the first mismatch or beginning</span>
    <span class="c1">// of the word</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="n">wordlen</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// delta2 table: given a mismatch at pat[pos], we want to align </span>
<span class="c1">// with the next possible full match could be based on what we</span>
<span class="c1">// know about pat[pos+1] to pat[patlen-1].</span>
<span class="c1">//</span>
<span class="c1">// In case 1:</span>
<span class="c1">// pat[pos+1] to pat[patlen-1] does not occur elsewhere in pat,</span>
<span class="c1">// the next plausible match starts at or after the mismatch.</span>
<span class="c1">// If, within the substring pat[pos+1 .. patlen-1], lies a prefix</span>
<span class="c1">// of pat, the next plausible match is here (if there are multiple</span>
<span class="c1">// prefixes in the substring, pick the longest). Otherwise, the</span>
<span class="c1">// next plausible match starts past the character aligned with </span>
<span class="c1">// pat[patlen-1].</span>
<span class="c1">// </span>
<span class="c1">// In case 2:</span>
<span class="c1">// pat[pos+1] to pat[patlen-1] does occur elsewhere in pat. The</span>
<span class="c1">// mismatch tells us that we are not looking at the end of a match.</span>
<span class="c1">// We may, however, be looking at the middle of a match.</span>
<span class="c1">// </span>
<span class="c1">// The first loop, which takes care of case 1, is analogous to</span>
<span class="c1">// the KMP table, adapted for a &#39;backwards&#39; scan order with the</span>
<span class="c1">// additional restriction that the substrings it considers as </span>
<span class="c1">// potential prefixes are all suffixes. In the worst case scenario</span>
<span class="c1">// pat consists of the same letter repeated, so every suffix is</span>
<span class="c1">// a prefix. This loop alone is not sufficient, however:</span>
<span class="c1">// Suppose that pat is &quot;ABYXCDBYX&quot;, and text is &quot;.....ABYXCDEYX&quot;.</span>
<span class="c1">// We will match X, Y, and find B != E. There is no prefix of pat</span>
<span class="c1">// in the suffix &quot;YX&quot;, so the first loop tells us to skip forward</span>
<span class="c1">// by 9 characters.</span>
<span class="c1">// Although superficially similar to the KMP table, the KMP table</span>
<span class="c1">// relies on information about the beginning of the partial match</span>
<span class="c1">// that the BM algorithm does not have.</span>
<span class="c1">//</span>
<span class="c1">// The second loop addresses case 2. Since suffix_length may not be</span>
<span class="c1">// unique, we want to take the minimum value, which will tell us</span>
<span class="c1">// how far away the closest potential match is.</span>
<span class="kt">void</span> <span class="nf">make_delta2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">delta2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pat</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">patlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">last_prefix_index</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// first loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">patlen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">p</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_prefix</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">patlen</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">last_prefix_index</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">delta2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_prefix_index</span> <span class="o">+</span> <span class="p">(</span><span class="n">patlen</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// second loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">slen</span> <span class="o">=</span> <span class="n">suffix_length</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">patlen</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">p</span> <span class="o">-</span> <span class="n">slen</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pat</span><span class="p">[</span><span class="n">patlen</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">slen</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">delta2</span><span class="p">[</span><span class="n">patlen</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">slen</span><span class="p">]</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="n">slen</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">uint8_t</span><span class="o">*</span> <span class="nf">boyer_moore</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">stringlen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pat</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">patlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">delta1</span><span class="p">[</span><span class="n">ALPHABET_LEN</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">delta2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">patlen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">make_delta1</span><span class="p">(</span><span class="n">delta1</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">patlen</span><span class="p">);</span>
    <span class="n">make_delta2</span><span class="p">(</span><span class="n">delta2</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">patlen</span><span class="p">);</span>

    <span class="c1">// The empty pattern must be considered specially</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">patlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">delta2</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">string</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringlen</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="p">{</span>
            <span class="o">--</span><span class="n">i</span><span class="p">;</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="n">delta2</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">string</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="n">max</span><span class="p">(</span><span class="n">delta1</span><span class="p">[</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">delta2</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">delta2</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="NavFrame collapsed">
<div class="NavHead">[Java implementation]</div>
<div class="NavContent">
<div style="text-align:left">
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span>    <span class="cm">/**</span>
<span class="cm">     * Returns the index within this string of the first occurrence of the</span>
<span class="cm">     * specified substring. If it is not a substring, return -1.</span>
<span class="cm">     * </span>
<span class="cm">     * @param haystack The string to be scanned</span>
<span class="cm">     * @param needle The target string to search</span>
<span class="cm">     * @return The start index of the substring</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">haystack</span><span class="o">,</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">charTable</span><span class="o">[]</span> <span class="o">=</span> <span class="n">makeCharTable</span><span class="o">(</span><span class="n">needle</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">offsetTable</span><span class="o">[]</span> <span class="o">=</span> <span class="n">makeOffsetTable</span><span class="o">(</span><span class="n">needle</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">;)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">needle</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">haystack</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">--</span><span class="n">i</span><span class="o">,</span> <span class="o">--</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// i += needle.length - j; // For naive method</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">offsetTable</span><span class="o">[</span><span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="o">],</span> <span class="n">charTable</span><span class="o">[</span><span class="n">haystack</span><span class="o">[</span><span class="n">i</span><span class="o">]]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**</span>
<span class="cm">     * Makes the jump table based on the mismatched character information.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">makeCharTable</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">ALPHABET_SIZE</span> <span class="o">=</span> <span class="n">Character</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 65536</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ALPHABET_SIZE</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">table</span><span class="o">[</span><span class="n">needle</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">table</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**</span>
<span class="cm">     * Makes the jump table based on the scan offset which mismatch occurs.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">makeOffsetTable</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">lastPrefixPosition</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isPrefix</span><span class="o">(</span><span class="n">needle</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">lastPrefixPosition</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">table</span><span class="o">[</span><span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">lastPrefixPosition</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">slen</span> <span class="o">=</span> <span class="n">suffixLength</span><span class="o">(</span><span class="n">needle</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="n">table</span><span class="o">[</span><span class="n">slen</span><span class="o">]</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="n">slen</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">table</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**</span>
<span class="cm">     * Is needle[p:end] a prefix of needle?</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrefix</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">needle</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">,</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">needle</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**</span>
<span class="cm">     * Returns the maximum length of the substring ends at p and is a suffix.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">suffixLength</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">needle</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                 <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">needle</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">needle</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> <span class="o">--</span><span class="n">i</span><span class="o">,</span> <span class="o">--</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">len</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<h2><span class="mw-headline" id="Variants">Variants</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=13" title="Edit section: Variants">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm" title="Boyer–Moore–Horspool algorithm">Boyer–Moore–Horspool algorithm</a> is a simplification of the Boyer–Moore algorithm using only the bad character rule.
</p><p>The <a href="/wiki/Apostolico%E2%80%93Giancarlo_algorithm" title="Apostolico–Giancarlo algorithm">Apostolico–Giancarlo algorithm</a> speeds up the process of checking whether a match has occurred at the given alignment by skipping explicit character comparisons. This uses information gleaned during the pre-processing of the pattern in conjunction with suffix match lengths recorded at each match attempt. Storing suffix match lengths requires an additional table equal in size to the text being searched.
</p><p>The <a href="/wiki/Raita_algorithm" title="Raita algorithm">Raita algorithm</a> improves the performance of Boyer-Moore-Horspool algorithm. The searching pattern of particular sub-string in a given string is different from Boyer-Moore-Horspool algorithm.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=14" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="mw-references-wrap"><ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><cite class="citation journal">Hume; Sunday (November 1991). "Fast String Searching". <i>Software—Practice and Experience</i>. <b>21</b> (11): 1221–1248.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Software%E2%80%94Practice+and+Experience&amp;rft.atitle=Fast+String+Searching&amp;rft.volume=21&amp;rft.issue=11&amp;rft.pages=1221-1248&amp;rft.date=1991-11&amp;rft.au=Hume&amp;rft.au=Sunday&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABoyer%E2%80%93Moore+string-search+algorithm" class="Z3988"></span><style data-mw-deduplicate="TemplateStyles:r879151008">.mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}</style></span>
</li>
<li id="cite_note-original-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-original_2-0">^</a></b></span> <span class="reference-text">
<cite class="citation journal"><a href="/wiki/Robert_S._Boyer" title="Robert S. Boyer">Boyer, Robert S.</a>; <a href="/wiki/J_Strother_Moore" title="J Strother Moore">Moore, J Strother</a> (October 1977). <a rel="nofollow" class="external text" href="http://dl.acm.org/citation.cfm?doid=359842.359859">"A Fast String Searching Algorithm"</a>. <i>Comm. ACM</i>. New York, NY, USA: Association for Computing Machinery. <b>20</b> (10): 762–772. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//doi.org/10.1145%2F359842.359859">10.1145/359842.359859</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a>&#160;<a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0001-0782">0001-0782</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Comm.+ACM&amp;rft.atitle=A+Fast+String+Searching+Algorithm.&amp;rft.volume=20&amp;rft.issue=10&amp;rft.pages=762-772&amp;rft.date=1977-10&amp;rft_id=info%3Adoi%2F10.1145%2F359842.359859&amp;rft.issn=0001-0782&amp;rft.aulast=Boyer&amp;rft.aufirst=Robert+S.&amp;rft.au=Moore%2C+J+Strother&amp;rft_id=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fdoid%3D359842.359859&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABoyer%E2%80%93Moore+string-search+algorithm" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-ASTS-3"><span class="mw-cite-backlink">^ <a href="#cite_ref-ASTS_3-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-ASTS_3-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">
<cite id="CITEREFGusfield1999" class="citation">Gusfield, Dan (1999) [1997], "Chapter 2 - Exact Matching: Classical Comparison-Based Methods", <i>Algorithms on Strings, Trees, and Sequences</i> (1 ed.), Cambridge University Press, pp.&#160;19–21, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0521585198" title="Special:BookSources/0521585198">0521585198</a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Chapter+2+-+Exact+Matching%3A+Classical+Comparison-Based+Methods&amp;rft.btitle=Algorithms+on+Strings%2C+Trees%2C+and+Sequences&amp;rft.pages=19-21&amp;rft.edition=1&amp;rft.pub=Cambridge+University+Press&amp;rft.date=1999&amp;rft.isbn=0521585198&amp;rft.aulast=Gusfield&amp;rft.aufirst=Dan&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABoyer%E2%80%93Moore+string-search+algorithm" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-galill-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-galill_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-galill_4-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">
<cite class="citation journal"><a href="/wiki/Zvi_Galil" title="Zvi Galil">Galil, Z.</a> (September 1979). <a rel="nofollow" class="external text" href="http://dl.acm.org/citation.cfm?id=359146.359148">"On improving the worst case running time of the Boyer-Moore string matching algorithm"</a>. <i>Comm. ACM</i>. New York, NY, USA: Association for Computing Machinery. <b>22</b> (9): 505–508. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//doi.org/10.1145%2F359146.359148">10.1145/359146.359148</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a>&#160;<a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0001-0782">0001-0782</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Comm.+ACM&amp;rft.atitle=On+improving+the+worst+case+running+time+of+the+Boyer-Moore+string+matching+algorithm&amp;rft.volume=22&amp;rft.issue=9&amp;rft.pages=505-508&amp;rft.date=1979-09&amp;rft_id=info%3Adoi%2F10.1145%2F359146.359148&amp;rft.issn=0001-0782&amp;rft.aulast=Galil&amp;rft.aufirst=Z.&amp;rft_id=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D359146.359148&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABoyer%E2%80%93Moore+string-search+algorithm" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-kmp-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-kmp_5-0">^</a></b></span> <span class="reference-text">
<cite class="citation journal"><a href="/wiki/Donald_Knuth" title="Donald Knuth">Knuth, Donald</a>; <a href="/wiki/James_H._Morris" title="James H. Morris">Morris, James H.</a>; <a href="/wiki/Vaughan_Pratt" title="Vaughan Pratt">Pratt, Vaughan</a> (1977). <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/context/23820/0">"Fast pattern matching in strings"</a>. <i>SIAM Journal on Computing</i>. <b>6</b> (2): 323–350. <a href="/wiki/CiteSeerX" title="CiteSeerX">CiteSeerX</a>&#160;<span class="cs1-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="//citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.93.8147">10.1.1.93.8147</a></span>. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//doi.org/10.1137%2F0206024">10.1137/0206024</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=SIAM+Journal+on+Computing&amp;rft.atitle=Fast+pattern+matching+in+strings&amp;rft.volume=6&amp;rft.issue=2&amp;rft.pages=323-350&amp;rft.date=1977&amp;rft_id=%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.93.8147&amp;rft_id=info%3Adoi%2F10.1137%2F0206024&amp;rft.aulast=Knuth&amp;rft.aufirst=Donald&amp;rft.au=Morris%2C+James+H.&amp;rft.au=Pratt%2C+Vaughan&amp;rft_id=http%3A%2F%2Fciteseer.ist.psu.edu%2Fcontext%2F23820%2F0&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABoyer%E2%80%93Moore+string-search+algorithm" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-go-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-go_6-0">^</a></b></span> <span class="reference-text">
<cite class="citation journal"><a href="/wiki/Leonidas_J._Guibas" title="Leonidas J. Guibas">Guibas, Leonidas</a>; <a href="/wiki/Andrew_Odlyzko" title="Andrew Odlyzko">Odlyzko, Andrew</a> (1977). <a rel="nofollow" class="external text" href="http://dl.acm.org/citation.cfm?id=1382431.1382552">"A new proof of the linearity of the Boyer-Moore string searching algorithm"</a>. <i>Proceedings of the 18th Annual Symposium on Foundations of Computer Science</i>. Washington, DC, USA: IEEE Computer Society: 189–195. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//doi.org/10.1109%2FSFCS.1977.3">10.1109/SFCS.1977.3</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+18th+Annual+Symposium+on+Foundations+of+Computer+Science&amp;rft.atitle=A+new+proof+of+the+linearity+of+the+Boyer-Moore+string+searching+algorithm&amp;rft.pages=189-195&amp;rft.date=1977&amp;rft_id=info%3Adoi%2F10.1109%2FSFCS.1977.3&amp;rft.aulast=Guibas&amp;rft.aufirst=Leonidas&amp;rft.au=Odlyzko%2C+Andrew&amp;rft_id=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D1382431.1382552&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABoyer%E2%80%93Moore+string-search+algorithm" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-cole-7"><span class="mw-cite-backlink">^ <a href="#cite_ref-cole_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-cole_7-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">
<cite class="citation journal">Cole, Richard (September 1991). <a rel="nofollow" class="external text" href="http://dl.acm.org/citation.cfm?id=127830">"Tight bounds on the complexity of the Boyer-Moore string matching algorithm"</a>. <i>Proceedings of the 2nd annual ACM-SIAM symposium on Discrete algorithms</i>. Philadelphia, PA, USA: Society for Industrial and Applied Mathematics: 224–233. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-89791-376-0" title="Special:BookSources/0-89791-376-0">0-89791-376-0</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+2nd+annual+ACM-SIAM+symposium+on+Discrete+algorithms&amp;rft.atitle=Tight+bounds+on+the+complexity+of+the+Boyer-Moore+string+matching+algorithm&amp;rft.pages=224-233&amp;rft.date=1991-09&amp;rft.isbn=0-89791-376-0&amp;rft.aulast=Cole&amp;rft.aufirst=Richard&amp;rft_id=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D127830&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABoyer%E2%80%93Moore+string-search+algorithm" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r879151008"/></span>
</li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html</a></span>
</li>
</ol></div>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit&amp;section=15" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table role="presentation" class="mbox-small plainlinks sistersitebox" style="background-color:#f9f9f9;border:1px solid #aaa;color:#000">
<tbody><tr>
<td class="mbox-image"><img alt="" src="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/30px-Commons-logo.svg.png" decoding="async" width="30" height="40" class="noviewer" srcset="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/45px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/59px-Commons-logo.svg.png 2x" data-file-width="1024" data-file-height="1376" /></td>
<td class="mbox-text plainlist">Wikimedia Commons has media related to <i><b><a href="https://commons.wikimedia.org/wiki/Category:Boyer%E2%80%93Moore_string_search_algorithm" class="extiw" title="commons:Category:Boyer–Moore string search algorithm">Boyer–Moore string search algorithm</a></b></i>.</td></tr></tbody></table>
<ul><li><a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf">Original paper on the Boyer-Moore algorithm</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/fstrpos-example.html">An example of the Boyer-Moore algorithm</a> from the homepage of <a href="/wiki/J_Strother_Moore" title="J Strother Moore">J Strother Moore</a>, co-inventor of the algorithm</li>
<li><a rel="nofollow" class="external text" href="http://www.cs.nyu.edu/cs/faculty/cole/papers/CHPZ95.ps">Richard Cole's 1991 paper proving runtime linearity</a></li></ul>
<div role="navigation" class="navbox" aria-labelledby="Strings" style="padding:3px"><table class="nowraplinks collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="col" class="navbox-title" colspan="2"><div class="plainlinks hlist navbar mini"><ul><li class="nv-view"><a href="/wiki/Template:Strings" title="Template:Strings"><abbr title="View this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">v</abbr></a></li><li class="nv-talk"><a href="/wiki/Template_talk:Strings" title="Template talk:Strings"><abbr title="Discuss this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">t</abbr></a></li><li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Strings&amp;action=edit"><abbr title="Edit this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">e</abbr></a></li></ul></div><div id="Strings" style="font-size:114%;margin:0 4em"><a href="/wiki/String_(computer_science)" title="String (computer science)">Strings</a></div></th></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/String_metric" title="String metric">String metric</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Approximate_string_matching" title="Approximate string matching">Approximate string matching</a></li>
<li><a href="/wiki/Bitap_algorithm" title="Bitap algorithm">Bitap algorithm</a></li>
<li><a href="/wiki/Damerau%E2%80%93Levenshtein_distance" title="Damerau–Levenshtein distance">Damerau–Levenshtein distance</a></li>
<li><a href="/wiki/Edit_distance" title="Edit distance">Edit distance</a></li>
<li><a href="/wiki/Hamming_distance" title="Hamming distance">Hamming distance</a></li>
<li><a href="/wiki/Jaro%E2%80%93Winkler_distance" title="Jaro–Winkler distance">Jaro–Winkler distance</a></li>
<li><a href="/wiki/Lee_distance" title="Lee distance">Lee distance</a></li>
<li><a href="/wiki/Levenshtein_automaton" title="Levenshtein automaton">Levenshtein automaton</a></li>
<li><a href="/wiki/Levenshtein_distance" title="Levenshtein distance">Levenshtein distance</a></li>
<li><a href="/wiki/Wagner%E2%80%93Fischer_algorithm" title="Wagner–Fischer algorithm">Wagner–Fischer algorithm </a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/String-searching_algorithm" title="String-searching algorithm">String-searching algorithm</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Apostolico%E2%80%93Giancarlo_algorithm" title="Apostolico–Giancarlo algorithm">Apostolico–Giancarlo algorithm</a></li>
<li><a class="mw-selflink selflink">Boyer–Moore string-search algorithm</a></li>
<li><a href="/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm" title="Boyer–Moore–Horspool algorithm">Boyer–Moore–Horspool algorithm</a></li>
<li><a href="/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" title="Knuth–Morris–Pratt algorithm">Knuth–Morris–Pratt algorithm</a></li>
<li><a href="/wiki/Rabin%E2%80%93Karp_algorithm" title="Rabin–Karp algorithm">Rabin–Karp string search algorithm</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%">Multiple string searching</th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Aho%E2%80%93Corasick_algorithm" title="Aho–Corasick algorithm">Aho–Corasick</a></li>
<li><a href="/wiki/Commentz-Walter_algorithm" title="Commentz-Walter algorithm">Commentz-Walter algorithm</a></li>
<li><a href="/wiki/Rabin%E2%80%93Karp_algorithm" title="Rabin–Karp algorithm">Rabin–Karp</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Regular_expression" title="Regular expression">Regular expression</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Comparison_of_regular_expression_engines" title="Comparison of regular expression engines">Comparison of regular expression engines</a></li>
<li><a href="/wiki/Regular_tree_grammar" title="Regular tree grammar">Regular tree grammar</a></li>
<li><a href="/wiki/Thompson%27s_construction" title="Thompson&#39;s construction">Thompson's construction</a></li>
<li><a href="/wiki/Nondeterministic_finite_automaton" title="Nondeterministic finite automaton">Nondeterministic finite automaton</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Sequence_alignment" title="Sequence alignment">Sequence alignment</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Hirschberg%27s_algorithm" title="Hirschberg&#39;s algorithm">Hirschberg's algorithm</a></li>
<li><a href="/wiki/Needleman%E2%80%93Wunsch_algorithm" title="Needleman–Wunsch algorithm">Needleman–Wunsch algorithm</a></li>
<li><a href="/wiki/Smith%E2%80%93Waterman_algorithm" title="Smith–Waterman algorithm">Smith–Waterman algorithm</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Category:String_data_structures" title="Category:String data structures">Data structures</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Deterministic_acyclic_finite_state_automaton" title="Deterministic acyclic finite state automaton">DAFSA</a></li>
<li><a href="/wiki/Suffix_array" title="Suffix array">Suffix array</a></li>
<li><a href="/wiki/Suffix_automaton" title="Suffix automaton">Suffix automaton</a></li>
<li><a href="/wiki/Suffix_tree" title="Suffix tree">Suffix tree</a></li>
<li><a href="/wiki/Generalized_suffix_tree" title="Generalized suffix tree">Generalized suffix tree</a></li>
<li><a href="/wiki/Rope_(data_structure)" title="Rope (data structure)">Rope</a></li>
<li><a href="/wiki/Ternary_search_tree" title="Ternary search tree">Ternary search tree</a></li>
<li><a href="/wiki/Trie" title="Trie">Trie</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%">Other</th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Parsing" title="Parsing">Parsing</a></li>
<li><a href="/wiki/Pattern_matching" title="Pattern matching">Pattern matching</a></li>
<li><a href="/wiki/Compressed_pattern_matching" title="Compressed pattern matching">Compressed pattern matching</a></li>
<li><a href="/wiki/Longest_common_subsequence" class="mw-redirect" title="Longest common subsequence">Longest common subsequence</a></li>
<li><a href="/wiki/Longest_common_substring" class="mw-redirect" title="Longest common substring">Longest common substring</a></li>
<li><a href="/wiki/Sequential_pattern_mining" title="Sequential pattern mining">Sequential pattern mining</a></li>
<li><a href="/wiki/Category:String_sorting_algorithms" title="Category:String sorting algorithms">Sorting</a></li></ul>
</div></td></tr></tbody></table></div>

<!-- 
NewPP limit report
Parsed by mw1329
Cached time: 20190214235704
Cache expiry: 2073600
Dynamic content: false
CPU time usage: 0.420 seconds
Real time usage: 1.339 seconds
Preprocessor visited node count: 1363/1000000
Preprocessor generated node count: 0/1500000
Post‐expand include size: 35279/2097152 bytes
Template argument size: 815/2097152 bytes
Highest expansion depth: 14/40
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 81384/5000000 bytes
Number of Wikibase entities loaded: 3/400
Lua time usage: 0.176/10.000 seconds
Lua memory usage: 4.08 MB/50 MB
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1005.546      1 -total
 16.27%  163.599      6 Template:Cite_journal
  8.54%   85.890      1 Template:Commonscat
  6.95%   69.857      1 Template:Commons
  6.74%   67.811      1 Template:Sister_project
  6.15%   61.847      1 Template:Side_box
  5.34%   53.704      2 Template:If_then_show
  3.46%   34.808      1 Template:For
  1.56%   15.721      1 Template:Citation
  1.47%   14.770      1 Template:Strings
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:684709-0!canonical!math=5 and timestamp 20190214235703 and revision id 857560043
 -->
</div><noscript><img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></noscript></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://en.wikipedia.org/w/index.php?title=Boyer–Moore_string-search_algorithm&amp;oldid=857560043">https://en.wikipedia.org/w/index.php?title=Boyer–Moore_string-search_algorithm&amp;oldid=857560043</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Help:Category" title="Help:Category">Categories</a>: <ul><li><a href="/wiki/Category:String_matching_algorithms" title="Category:String matching algorithms">String matching algorithms</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul><li><a href="/wiki/Category:Commons_category_link_from_Wikidata" title="Category:Commons category link from Wikidata">Commons category link from Wikidata</a></li><li><a href="/wiki/Category:Articles_with_example_C_code" title="Category:Articles with example C code">Articles with example C code</a></li><li><a href="/wiki/Category:Articles_with_example_Python_code" title="Category:Articles with example Python code">Articles with example Python code</a></li><li><a href="/wiki/Category:Articles_with_example_Java_code" title="Category:Articles with example Java code">Articles with example Java code</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-anonuserpage">Not logged in</li><li id="pt-anontalk"><a href="/wiki/Special:MyTalk" title="Discussion about edits from this IP address [n]" accesskey="n">Talk</a></li><li id="pt-anoncontribs"><a href="/wiki/Special:MyContributions" title="A list of edits made from this IP address [y]" accesskey="y">Contributions</a></li><li id="pt-createaccount"><a href="/w/index.php?title=Special:CreateAccount&amp;returnto=Boyer%E2%80%93Moore+string-search+algorithm" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Boyer%E2%80%93Moore+string-search+algorithm" title="You&#039;re encouraged to log in; however, it&#039;s not mandatory. [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="/wiki/Boyer%E2%80%93Moore_string-search_algorithm" title="View the content page [c]" accesskey="c">Article</a></span></li><li id="ca-talk"><span><a href="/wiki/Talk:Boyer%E2%80%93Moore_string-search_algorithm" rel="discussion" title="Discussion about the content page [t]" accesskey="t">Talk</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<ul class="menu">
													</ul>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="/wiki/Boyer%E2%80%93Moore_string-search_algorithm">Read</a></span></li><li id="ca-edit" class="collapsible"><span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=edit" title="Edit this page [e]" accesskey="e">Edit</a></span></li><li id="ca-history" class="collapsible"><span><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<ul class="menu">
													</ul>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="/w/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Wikipedia" title="Search Wikipedia [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search Wikipedia for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page" title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li><li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li><li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content – the best of Wikipedia">Featured content</a></li><li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li><li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li><li id="n-sitesupport"><a href="https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikipedia.org&amp;uselang=en" title="Support us">Donate to Wikipedia</a></li><li id="n-shoplink"><a href="//shop.wikimedia.org" title="Visit the Wikipedia store">Wikipedia store</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-interaction" aria-labelledby="p-interaction-label">
			<h3 id="p-interaction-label">Interaction</h3>
			<div class="body">
								<ul>
					<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li><li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li><li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li><li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-contactpage"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact page</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Tools</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Boyer%E2%80%93Moore_string-search_algorithm" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Boyer%E2%80%93Moore_string-search_algorithm" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-upload"><a href="/wiki/Wikipedia:File_Upload_Wizard" title="Upload files [u]" accesskey="u">Upload file</a></li><li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-permalink"><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;oldid=857560043" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;action=info" title="More information about this page">Page information</a></li><li id="t-wikibase"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q895984" title="Link to connected data repository item [g]" accesskey="g">Wikidata item</a></li><li id="t-cite"><a href="/w/index.php?title=Special:CiteThisPage&amp;page=Boyer%E2%80%93Moore_string-search_algorithm&amp;id=857560043" title="Information on how to cite this page">Cite this page</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-coll-print_export" aria-labelledby="p-coll-print_export-label">
			<h3 id="p-coll-print_export-label">Print/export</h3>
			<div class="body">
								<ul>
					<li id="coll-create_a_book"><a href="/w/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=Boyer%E2%80%93Moore+string-search+algorithm">Create a book</a></li><li id="coll-download-as-rdf2latex"><a href="/w/index.php?title=Special:ElectronPdf&amp;page=Boyer%E2%80%93Moore+string-search+algorithm&amp;action=show-download-screen">Download as PDF</a></li><li id="t-print"><a href="/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-wikibase-otherprojects" aria-labelledby="p-wikibase-otherprojects-label">
			<h3 id="p-wikibase-otherprojects-label">In other projects</h3>
			<div class="body">
								<ul>
					<li class="wb-otherproject-link wb-otherproject-commons"><a href="https://commons.wikimedia.org/wiki/Category:Boyer%E2%80%93Moore_string_search_algorithm" hreflang="en">Wikimedia Commons</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-lang" aria-labelledby="p-lang-label">
			<h3 id="p-lang-label">Languages</h3>
			<div class="body">
								<ul>
					<li class="interlanguage-link interwiki-de"><a href="https://de.wikipedia.org/wiki/Boyer-Moore-Algorithmus" title="Boyer-Moore-Algorithmus – German" lang="de" hreflang="de" class="interlanguage-link-target">Deutsch</a></li><li class="interlanguage-link interwiki-es"><a href="https://es.wikipedia.org/wiki/Algoritmo_de_b%C3%BAsqueda_de_cadenas_Boyer-Moore" title="Algoritmo de búsqueda de cadenas Boyer-Moore – Spanish" lang="es" hreflang="es" class="interlanguage-link-target">Español</a></li><li class="interlanguage-link interwiki-fa"><a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%84%DA%AF%D9%88%D8%B1%DB%8C%D8%AA%D9%85_%D8%A8%D9%88%DB%8C%D8%B1_%D9%85%D9%88%D8%B1" title="الگوریتم بویر مور – Persian" lang="fa" hreflang="fa" class="interlanguage-link-target">فارسی</a></li><li class="interlanguage-link interwiki-fr"><a href="https://fr.wikipedia.org/wiki/Algorithme_de_Boyer-Moore" title="Algorithme de Boyer-Moore – French" lang="fr" hreflang="fr" class="interlanguage-link-target">Français</a></li><li class="interlanguage-link interwiki-id"><a href="https://id.wikipedia.org/wiki/Algoritme_Boyer-Moore" title="Algoritme Boyer-Moore – Indonesian" lang="id" hreflang="id" class="interlanguage-link-target">Bahasa Indonesia</a></li><li class="interlanguage-link interwiki-it"><a href="https://it.wikipedia.org/wiki/Algoritmo_di_Boyer-Moore" title="Algoritmo di Boyer-Moore – Italian" lang="it" hreflang="it" class="interlanguage-link-target">Italiano</a></li><li class="interlanguage-link interwiki-he"><a href="https://he.wikipedia.org/wiki/%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9D_%D7%91%D7%95%D7%99%D7%90%D7%A8-%D7%9E%D7%95%D7%A8" title="אלגוריתם בויאר-מור – Hebrew" lang="he" hreflang="he" class="interlanguage-link-target">עברית</a></li><li class="interlanguage-link interwiki-lt"><a href="https://lt.wikipedia.org/wiki/Blogo_simbolio_taisykl%C4%97" title="Blogo simbolio taisyklė – Lithuanian" lang="lt" hreflang="lt" class="interlanguage-link-target">Lietuvių</a></li><li class="interlanguage-link interwiki-ja"><a href="https://ja.wikipedia.org/wiki/%E3%83%9C%E3%82%A4%E3%83%A4%E3%83%BC-%E3%83%A0%E3%83%BC%E3%82%A2%E6%96%87%E5%AD%97%E5%88%97%E6%A4%9C%E7%B4%A2%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0" title="ボイヤー-ムーア文字列検索アルゴリズム – Japanese" lang="ja" hreflang="ja" class="interlanguage-link-target">日本語</a></li><li class="interlanguage-link interwiki-pl"><a href="https://pl.wikipedia.org/wiki/Algorytm_Boyera_i_Moore%E2%80%99a" title="Algorytm Boyera i Moore’a – Polish" lang="pl" hreflang="pl" class="interlanguage-link-target">Polski</a></li><li class="interlanguage-link interwiki-pt"><a href="https://pt.wikipedia.org/wiki/Algoritmo_de_busca_de_express%C3%B5es_Boyer-Moore" title="Algoritmo de busca de expressões Boyer-Moore – Portuguese" lang="pt" hreflang="pt" class="interlanguage-link-target">Português</a></li><li class="interlanguage-link interwiki-ru"><a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D0%BE%D0%B9%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%9C%D1%83%D1%80%D0%B0" title="Алгоритм Бойера — Мура – Russian" lang="ru" hreflang="ru" class="interlanguage-link-target">Русский</a></li><li class="interlanguage-link interwiki-sr"><a href="https://sr.wikipedia.org/wiki/%D0%91%D0%BE%D1%98%D0%B5%D1%80-%D0%9C%D1%83%D1%80_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%B0%D0%BC_%D0%B7%D0%B0_%D0%BF%D1%80%D0%B5%D1%82%D1%80%D0%B0%D0%B3%D1%83_%D0%BD%D0%B8%D1%81%D0%BA%D0%B8" title="Бојер-Мур алгоритам за претрагу ниски – Serbian" lang="sr" hreflang="sr" class="interlanguage-link-target">Српски / srpski</a></li><li class="interlanguage-link interwiki-th"><a href="https://th.wikipedia.org/wiki/%E0%B8%82%E0%B8%B1%E0%B9%89%E0%B8%99%E0%B8%95%E0%B8%AD%E0%B8%99%E0%B8%A7%E0%B8%B4%E0%B8%98%E0%B8%B5%E0%B8%84%E0%B9%89%E0%B8%99%E0%B8%AB%E0%B8%B2%E0%B8%AA%E0%B8%B2%E0%B8%A2%E0%B8%AD%E0%B8%B1%E0%B8%81%E0%B8%82%E0%B8%A3%E0%B8%B0%E0%B8%9A%E0%B8%AD%E0%B8%A2%E0%B9%80%E0%B8%A2%E0%B8%AD%E0%B8%A3%E0%B9%8C%E2%80%93%E0%B8%A1%E0%B8%B1%E0%B8%A7%E0%B8%A3%E0%B9%8C" title="ขั้นตอนวิธีค้นหาสายอักขระบอยเยอร์–มัวร์ – Thai" lang="th" hreflang="th" class="interlanguage-link-target">ไทย</a></li><li class="interlanguage-link interwiki-uk"><a href="https://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D0%BE%D0%B9%D0%B5%D1%80%D0%B0_%D0%9C%D1%83%D1%80%D0%B0" title="Алгоритм Бойера Мура – Ukrainian" lang="uk" hreflang="uk" class="interlanguage-link-target">Українська</a></li><li class="interlanguage-link interwiki-zh"><a href="https://zh.wikipedia.org/wiki/Boyer-Moore%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" title="Boyer-Moore字符串搜索算法 – Chinese" lang="zh" hreflang="zh" class="interlanguage-link-target">中文</a></li>				</ul>
				<div class="after-portlet after-portlet-lang"><span class="wb-langlinks-edit wb-langlinks-link"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q895984#sitelinks-wikipedia" title="Edit interlanguage links" class="wbc-editpage">Edit links</a></span></div>			</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 1 September 2018, at 13:43<span class="anonymous-show">&#160;(UTC)</span>.</li>
								<li id="footer-info-copyright">Text is available under the <a rel="license" href="//en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a><a rel="license" href="//creativecommons.org/licenses/by-sa/3.0/" style="display:none;"></a>;
additional terms may apply.  By using this site, you agree to the <a href="//foundation.wikimedia.org/wiki/Terms_of_Use">Terms of Use</a> and <a href="//foundation.wikimedia.org/wiki/Privacy_policy">Privacy Policy</a>. Wikipedia® is a registered trademark of the <a href="//www.wikimediafoundation.org/">Wikimedia Foundation, Inc.</a>, a non-profit organization.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="https://foundation.wikimedia.org/wiki/Privacy_policy" class="extiw" title="wmf:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
								<li id="footer-places-disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-contact"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>
								<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Developers</a></li>
								<li id="footer-places-cookiestatement"><a href="https://foundation.wikimedia.org/wiki/Cookie_statement">Cookie statement</a></li>
								<li id="footer-places-mobileview"><a href="//en.m.wikipedia.org/w/index.php?title=Boyer%E2%80%93Moore_string-search_algorithm&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="https://wikimediafoundation.org/"><img src="/static/images/wikimedia-button.png" srcset="/static/images/wikimedia-button-1.5x.png 1.5x, /static/images/wikimedia-button-2x.png 2x" width="88" height="31" alt="Wikimedia Foundation"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="//www.mediawiki.org/"><img src="/static/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/static/images/poweredby_mediawiki_132x47.png 1.5x, /static/images/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.420","walltime":"1.339","ppvisitednodes":{"value":1363,"limit":1000000},"ppgeneratednodes":{"value":0,"limit":1500000},"postexpandincludesize":{"value":35279,"limit":2097152},"templateargumentsize":{"value":815,"limit":2097152},"expansiondepth":{"value":14,"limit":40},"expensivefunctioncount":{"value":3,"limit":500},"unstrip-depth":{"value":1,"limit":20},"unstrip-size":{"value":81384,"limit":5000000},"entityaccesscount":{"value":3,"limit":400},"timingprofile":["100.00% 1005.546      1 -total"," 16.27%  163.599      6 Template:Cite_journal","  8.54%   85.890      1 Template:Commonscat","  6.95%   69.857      1 Template:Commons","  6.74%   67.811      1 Template:Sister_project","  6.15%   61.847      1 Template:Side_box","  5.34%   53.704      2 Template:If_then_show","  3.46%   34.808      1 Template:For","  1.56%   15.721      1 Template:Citation","  1.47%   14.770      1 Template:Strings"]},"scribunto":{"limitreport-timeusage":{"value":"0.176","limit":"10.000"},"limitreport-memusage":{"value":4273941,"limit":52428800}},"cachereport":{"origin":"mw1329","timestamp":"20190214235704","ttl":2073600,"transientcontent":false}}});});</script>
<script type="application/ld+json">{"@context":"https:\/\/schema.org","@type":"Article","name":"Boyer\u2013Moore string-search algorithm","url":"https:\/\/en.wikipedia.org\/wiki\/Boyer%E2%80%93Moore_string-search_algorithm","sameAs":"http:\/\/www.wikidata.org\/entity\/Q895984","mainEntity":"http:\/\/www.wikidata.org\/entity\/Q895984","author":{"@type":"Organization","name":"Contributors to Wikimedia projects"},"publisher":{"@type":"Organization","name":"Wikimedia Foundation, Inc.","logo":{"@type":"ImageObject","url":"https:\/\/www.wikimedia.org\/static\/images\/wmf-hor-googpub.png"}},"datePublished":"2004-05-28T11:04:12Z","dateModified":"2018-09-01T13:43:14Z","headline":"string searching algorithm"}</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":104,"wgHostname":"mw1254"});});</script>
	</body>
</html>
